<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Manager Simulator – Next Version</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      background: #f8f9fa;
    }

    .container {
      max-width: 900px;
      margin: 1rem auto;
      padding: 1.5rem;
      background: #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.05);
      border-radius: 5px;
    }

    h1, h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    .section {
      margin-bottom: 1.5rem;
      border-bottom: 1px solid #ddd;
      padding-bottom: 1rem;
    }

    .btn {
      padding: 0.4rem 0.8rem;
      border: none;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      border-radius: 3px;
      margin-left: 0.5rem;
      font-size: 0.9rem;
    }
    .btn:hover {
      background: #0069d9;
    }

    /* Client Profile Layout */
    #client-profile {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .profile-info {
      flex: 1;
      min-width: 240px;
      margin-right: 1rem;
    }
    .profile-actions {
      margin-top: 1rem;
    }

    /* 
      Make Portfolio Value editable.
      We'll treat the #clientValue span the same way we do Proposed columns:
      single-click -> inline edit -> scale the entire portfolio.
    */
    .editable-field {
      cursor: pointer;
      border: 1px solid transparent;
      padding: 2px 4px;
      background: #fafafa;
    }
    .editable-field input {
      width: 80px;
      border: 1px solid #007bff;
      outline: none;
      font: inherit;
      box-sizing: border-box;
      text-align: right;
    }

    /* Portfolio Header with only a "Reset Trades" button on the right. */
    .portfolio-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .portfolio-buttons {
      display: flex;
      gap: 0.5rem;
    }

    /* Table (11 columns) with a total row at the bottom. */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.5rem 0;
    }
    th, td {
      text-align: left;
      padding: 0.4rem;
      border-bottom: 1px solid #eee;
      vertical-align: middle;
    }
    th {
      background: #f0f0f0;
    }
    tfoot td {
      font-weight: bold;
    }

    /* Proposed columns need a visible border to indicate editability. */
    .proposed-col {
      border: 1px dotted #007bff; /* indicates editable column */
      background: #fafafa;
      cursor: pointer;
    }
    .proposed-col input {
      /* same styling as above, plus dotted border would remain visible. */
      border: 1px solid #007bff;
      padding: 2px 4px;
      text-align: right;
      width: 100%;
    }

    /* Color-coded Delta columns. Positive => red, Negative => green. */
    .delta-positive {
      color: red;
    }
    .delta-negative {
      color: green;
    }

    .charts-container {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }
    .chart-box {
      flex: 1;
      min-width: 270px;
      max-width: 400px;
      max-height: 400px;
      position: relative;
      margin: auto;
      background: #f9f9f9;
      border-radius: 4px;
      padding: 1rem;
      text-align: center;
    }
    .chart-title {
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    .chart-box canvas {
      width: 100% !important;
      height: 100% !important;
    }

    @media (max-width: 700px) {
      .charts-container {
        flex-direction: column;
      }
      .chart-box {
        max-width: 100%;
        margin-bottom: 1rem;
      }
    }

    .footer {
      text-align: center;
      margin-top: 2rem;
      font-size: 0.85rem;
      color: #666;
    }

    .success {
      color: green;
      font-weight: bold;
    }
    .error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Portfolio Manager Simulator</h1>

  <!-- SECTION: CLIENT PROFILE -->
  <div class="section">
    <h2>Client Profile</h2>
    <div id="client-profile">
      <div class="profile-info">
        <p>
          <strong>Name:</strong>
          <span id="clientName">--</span>
        </p>
        <p>
          <strong>Risk Tolerance:</strong>
          <span id="clientRisk">--</span>
        </p>
        <p>
          <strong>Portfolio Value:</strong>
          <!-- Single-click to edit this value -->
          $<span id="clientValue" class="editable-field">0</span>
        </p>
        <p>
          <strong>Target Allocation:</strong>
          <span id="targetStocks">--</span>% Stocks, 
          <span id="targetBonds">--</span>% Bonds, 
          <span id="targetCash">--</span>% Cash
        </p>

        <!-- Move "Generate New Client" button to bottom of client profile. -->
        <div class="profile-actions">
          <button class="btn" id="newClientBtn">Generate New Client</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION: CURRENT (or Projected) PORTFOLIO -->
  <div class="section">
    <div class="portfolio-header">
      <h2>Current (or Projected) Portfolio</h2>
      <div class="portfolio-buttons">
        <!-- Remove Rebalance button; keep only Reset Trades, right-aligned. -->
        <button class="btn" id="resetTradesBtn">Reset Trades</button>
      </div>
    </div>

    <!--
      11 columns in the specified order:

      1)  Asset
      2)  Current ($)
      3)  Target ($)
      4)  Proposed +/- ($)
      5)  Final ($)
      6)  Delta ($)
      7)  Current (%)
      8)  Target (%)
      9)  Proposed +/- (%)
      10) Final (%)
      11) Delta (%)
    -->
    <table id="portfolioTable">
      <thead>
        <tr>
          <th>Asset</th>
          <th>Current ($)</th>
          <th>Target ($)</th>
          <th>Proposed +/- ($)</th>
          <th>Final ($)</th>
          <th>Delta ($)</th>
          <th>Current (%)</th>
          <th>Target (%)</th>
          <th>Proposed +/- (%)</th>
          <th>Final (%)</th>
          <th>Delta (%)</th>
        </tr>
      </thead>
      <tbody id="portfolioRows"></tbody>
      <tfoot>
        <tr id="totalRow"></tr>
      </tfoot>
    </table>

    <!-- Pie Charts: Target on LEFT, Final on RIGHT -->
    <div class="charts-container">
      <div class="chart-box">
        <div class="chart-title">Target Allocation</div>
        <canvas id="targetChart"></canvas>
      </div>
      <div class="chart-box">
        <div class="chart-title">Final Allocation</div>
        <canvas id="finalChart"></canvas>
      </div>
    </div>
  </div>

  <p id="tradeMessage"></p>
</div>

<div class="footer">
  &copy; Next Version – Combined Requirements
</div>

<!-- SCRIPTS -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/**
 * KEY POINTS:

 * 1) Proposed(%) & Proposed($) each reference the TOTAL portfolio value.
 *    Proposed($) = (Proposed(%) / 100) * totalPortfolioValue
 *    Final($)    = Current($) + Proposed($)
 *    Delta($)    = Final($) - Target($)
 *    Delta(%)    = Final(%) - Target(%)
 *
 * 2) "Reset Trades" sets Proposed=0 but does NOT recalc final => we preserve the existing Final values.
 *    So effectively, if the user previously had final > target, those remain. 
 *    If the user changes Proposed after that, we do recalc final from scratch (based on current + proposed).
 *
 * 3) We remove the "Rebalance" button entirely. The user changes Proposed columns, and the table/pie update automatically.
 *
 * 4) The "Portfolio Value" is now single-click editable. 
 *    If changed, we scale all dollar amounts in each row (current, target, final, proposed) proportionally to keep the same distribution.
 *    Then recalc the percentages & re-render.
 *
 * 5) Delta(%) must round to 2 decimals, removing negative zeros.
 * 6) Positive Delta => red, negative => green, zero => black.
 * 7) Totals row includes Delta columns as well.
*/

let totalPortfolioValue = 0;
let assets = []; // same structure as before
let finalChart, targetChart;

/** Generate random client data. */
function generateRandomClient() {
  const names = ['John Smith','Jane Doe','Alex Johnson','Maria Garcia','Lee Wong'];
  const riskLevels = [
    { label:'Conservative', stockPct:0.3, bondPct:0.5, cashPct:0.2 },
    { label:'Moderate',     stockPct:0.5, bondPct:0.4, cashPct:0.1 },
    { label:'Aggressive',   stockPct:0.7, bondPct:0.2, cashPct:0.1 }
  ];
  const randName = names[Math.floor(Math.random()*names.length)];
  const randRisk = riskLevels[Math.floor(Math.random()*riskLevels.length)];

  return {
    name: randName,
    risk: randRisk.label,
    portfolioValue: 100000,
    stockPct: randRisk.stockPct,
    bondPct:  randRisk.bondPct,
    cashPct:  randRisk.cashPct
  };
}

/** Called when user clicks "Generate New Client" or at startup. */
function newRandomClient() {
  const c = generateRandomClient();
  totalPortfolioValue = c.portfolioValue;

  // Randomly deviate current from target
  const deviate = () => (Math.random()*0.2 - 0.1);
  let stShare = c.stockPct + deviate();
  let boShare = c.bondPct  + deviate();
  let caShare = c.cashPct  + deviate();
  let sum     = Math.max(stShare+boShare+caShare, 0.0001);

  let stPct   = stShare/sum;
  let boPct   = boShare/sum;
  let caPct   = caShare/sum;

  // Current($)
  let curSt= stPct* totalPortfolioValue;
  let tarSt= c.stockPct* totalPortfolioValue;
  let curBo= boPct* totalPortfolioValue;
  let tarBo= c.bondPct* totalPortfolioValue;
  let curCa= caPct* totalPortfolioValue;
  let tarCa= c.cashPct* totalPortfolioValue;

  assets = [
    {
      name:'Stocks',
      currentDollar: curSt,
      currentPct: (curSt/ totalPortfolioValue)*100,
      targetDollar: tarSt,
      targetPct: (tarSt/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curSt,
      finalPct: (curSt/ totalPortfolioValue)*100
    },
    {
      name:'Bonds',
      currentDollar: curBo,
      currentPct: (curBo/ totalPortfolioValue)*100,
      targetDollar: tarBo,
      targetPct: (tarBo/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curBo,
      finalPct: (curBo/ totalPortfolioValue)*100
    },
    {
      name:'Cash',
      currentDollar: curCa,
      currentPct: (curCa/ totalPortfolioValue)*100,
      targetDollar: tarCa,
      targetPct: (tarCa/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curCa,
      finalPct: (curCa/ totalPortfolioValue)*100
    }
  ];

  // Update the profile info
  document.getElementById('clientName').textContent = c.name;
  document.getElementById('clientRisk').textContent = c.risk;
  document.getElementById('clientValue').textContent = formatMoney(c.portfolioValue);
  document.getElementById('targetStocks').textContent = (c.stockPct*100).toFixed(0);
  document.getElementById('targetBonds').textContent  = (c.bondPct*100).toFixed(0);
  document.getElementById('targetCash').textContent   = (c.cashPct*100).toFixed(0);

  document.getElementById('tradeMessage').textContent = '';
  renderTableAndCharts();
}

/** Renders the table plus updates the charts. */
function renderTableAndCharts(){
  const tbody = document.getElementById('portfolioRows');
  tbody.innerHTML = '';

  // We'll accumulate sums for the total row
  let sumCurrentD=0, sumTargetD=0, sumProposedD=0, sumFinalD=0;
  let sumCurrentPct=0, sumTargetPct=0, sumProposedPct=0, sumFinalPct=0;

  assets.forEach( (row,idx) => {
    // Delta($)= finalDollar - targetDollar
    const deltaDollar= row.finalDollar - row.targetDollar;
    // Delta(%)= finalPct - targetPct
    const deltaPct   = row.finalPct - row.targetPct;

    // accumulate sums
    sumCurrentD   += row.currentDollar;
    sumTargetD    += row.targetDollar;
    sumProposedD  += row.proposedDollar;
    sumFinalD     += row.finalDollar;
    sumCurrentPct += row.currentPct;
    sumTargetPct  += row.targetPct;
    sumProposedPct+= row.proposedPct;
    sumFinalPct   += row.finalPct;

    const tr = document.createElement('tr');

    // (1) Asset
    const tdAsset = document.createElement('td');
    tdAsset.textContent = row.name;
    tr.appendChild(tdAsset);

    // (2) Current($)
    const tdCurrentD = document.createElement('td');
    tdCurrentD.textContent = formatMoney(row.currentDollar);
    tr.appendChild(tdCurrentD);

    // (3) Target($)
    const tdTargetD = document.createElement('td');
    tdTargetD.textContent = formatMoney(row.targetDollar);
    tr.appendChild(tdTargetD);

    // (4) Proposed +/-($) - single-click editable
    const tdPropD = document.createElement('td');
    tdPropD.className = 'proposed-col'; 
    tdPropD.textContent = formatMoney(row.proposedDollar);
    tdPropD.onclick = () => makeEditable(tdPropD, idx, 'dollar');
    tr.appendChild(tdPropD);

    // (5) Final($)
    const tdFinalD = document.createElement('td');
    tdFinalD.textContent = formatMoney(row.finalDollar);
    tr.appendChild(tdFinalD);

    // (6) Delta($)
    const tdDeltaD= document.createElement('td');
    tdDeltaD.textContent= formatMoney(deltaDollar);
    colorDeltaCell(tdDeltaD, deltaDollar);
    tr.appendChild(tdDeltaD);

    // (7) Current(%)
    const tdCurrentPct = document.createElement('td');
    tdCurrentPct.textContent = row.currentPct.toFixed(2)+'%';
    tr.appendChild(tdCurrentPct);

    // (8) Target(%)
    const tdTargetPct = document.createElement('td');
    tdTargetPct.textContent = row.targetPct.toFixed(2)+'%';
    tr.appendChild(tdTargetPct);

    // (9) Proposed +/-(%) - single-click editable
    const tdPropPct = document.createElement('td');
    tdPropPct.className = 'proposed-col';
    tdPropPct.textContent = row.proposedPct.toFixed(2)+'%';
    tdPropPct.onclick = () => makeEditable(tdPropPct, idx, 'percent');
    tr.appendChild(tdPropPct);

    // (10) Final(%)
    const tdFinalPct = document.createElement('td');
    tdFinalPct.textContent = row.finalPct.toFixed(2)+'%';
    tr.appendChild(tdFinalPct);

    // (11) Delta(%)
    const tdDeltaPct= document.createElement('td');
    let deltaPctStr = roundDeltaPct(deltaPct);
    tdDeltaPct.textContent= deltaPctStr;
    colorDeltaCell(tdDeltaPct, parseFloat(deltaPctStr));
    tr.appendChild(tdDeltaPct);

    tbody.appendChild(tr);
  });

  // Now build the total row (including Delta)
  const tfoot = document.getElementById('totalRow');
  tfoot.innerHTML= '';

  const sumDeltaDollar= sumFinalD - sumTargetD;
  const sumDeltaPct   = sumFinalPct - sumTargetPct;

  // 11 columns
  // 1) "TOTAL"
  const col1= document.createElement('td');
  col1.textContent= 'TOTAL';
  tfoot.appendChild(col1);

  // 2) sum of Current($)
  const col2= document.createElement('td');
  col2.textContent= formatMoney(sumCurrentD);
  tfoot.appendChild(col2);

  // 3) sum of Target($)
  const col3= document.createElement('td');
  col3.textContent= formatMoney(sumTargetD);
  tfoot.appendChild(col3);

  // 4) sum of Proposed($)
  const col4= document.createElement('td');
  col4.textContent= formatMoney(sumProposedD);
  tfoot.appendChild(col4);

  // 5) sum of Final($)
  const col5= document.createElement('td');
  col5.textContent= formatMoney(sumFinalD);
  tfoot.appendChild(col5);

  // 6) Delta($)
  const col6= document.createElement('td');
  col6.textContent= formatMoney(sumDeltaDollar);
  colorDeltaCell(col6, sumDeltaDollar);
  tfoot.appendChild(col6);

  // 7) sum of Current(%)
  const col7= document.createElement('td');
  col7.textContent= sumCurrentPct.toFixed(2)+'%';
  tfoot.appendChild(col7);

  // 8) sum of Target(%)
  const col8= document.createElement('td');
  col8.textContent= sumTargetPct.toFixed(2)+'%';
  tfoot.appendChild(col8);

  // 9) sum of Proposed(%)
  const col9= document.createElement('td');
  col9.textContent= sumProposedPct.toFixed(2)+'%';
  tfoot.appendChild(col9);

  // 10) sum of Final(%)
  const col10= document.createElement('td');
  col10.textContent= sumFinalPct.toFixed(2)+'%';
  tfoot.appendChild(col10);

  // 11) Delta(%)
  const col11= document.createElement('td');
  let sumDeltaStr= roundDeltaPct(sumDeltaPct);
  col11.textContent= sumDeltaStr;
  colorDeltaCell(col11, parseFloat(sumDeltaStr));
  tfoot.appendChild(col11);

  // Update charts
  updateCharts();
}

/** Single-click editing for Proposed($ or %) cells. */
function makeEditable(cell, assetIndex, mode){
  const oldVal= cell.textContent.replace(/[^\d.-]/g,'');
  // Temporarily remove click and text
  cell.onclick= null;
  cell.innerHTML= '';

  const input= document.createElement('input');
  input.type='text';
  input.value= oldVal || '0';
  setTimeout(()=>input.select(),0);

  // On blur or Enter => finalize
  input.onblur= ()=> finishProposedEdit(cell, input.value, assetIndex, mode);
  input.onkeydown= (ev)=>{
    if(ev.key==='Enter'){
      ev.preventDefault();
      input.blur();
    }
  };
  cell.appendChild(input);
  input.focus();
}

/** 
 * Proposed(%) => Proposed($)= (Proposed(%) /100)* totalPortfolioValue
 * Final($)= current($)+ proposed($)
 * Final(%)= final($)/ totalPortfolioValue*100
 *
 * Note: If user previously "Reset Trades," final won't be recalculated 
 * unless user changes Proposed or changes portfolio value again.
 */
function finishProposedEdit(cell, rawVal, assetIndex, mode){
  let val= parseFloat(rawVal)||0;
  let row= assets[assetIndex];

  if(mode==='percent'){
    row.proposedPct= val;
    row.proposedDollar= (val/100)* totalPortfolioValue;
    row.finalDollar= row.currentDollar + row.proposedDollar;
    row.finalPct= (row.finalDollar/ totalPortfolioValue)*100;
  } else {
    // mode='dollar'
    row.proposedDollar= val;
    row.proposedPct= (val/ totalPortfolioValue)*100;
    row.finalDollar= row.currentDollar + val;
    row.finalPct= (row.finalDollar/ totalPortfolioValue)*100;
  }

  renderTableAndCharts();

  // restore single-click for next time
  if(mode==='percent'){
    cell.textContent= row.proposedPct.toFixed(2)+'%';
    cell.onclick= ()=> makeEditable(cell, assetIndex, 'percent');
  } else {
    cell.textContent= formatMoney(row.proposedDollar);
    cell.onclick= ()=> makeEditable(cell, assetIndex, 'dollar');
  }
}

/** "Reset Trades" => Proposed=0, but do NOT recalc final => we preserve final as is. */
function doResetTrades(){
  assets.forEach(a=>{
    a.proposedDollar=0;
    a.proposedPct=0;
    // "does not reset final" => keep finalDollar, finalPct
  });
  // We only update the table so Proposed columns read 0. The final columns remain.
  // We'll just do a partial re-render: no formula recalc for final.

  // Instead of calling the normal recalc flow, let's rebuild table 
  // but skip rewriting final columns from current+proposed formula.
  // We'll just display them as stored in the object.
  // This means we do not override finalDollar, finalPct from "current+ proposed."
  // So let's call a specialized function that doesn't recalc final:

  renderTableAndCharts();
  document.getElementById('tradeMessage').textContent='All proposed trades reset to 0 (Final unchanged).';
}

/** Adjust entire portfolio value if user single-clicks the #clientValue. */
(function enablePortfolioValueEdit(){
  const valSpan= document.getElementById('clientValue');
  valSpan.onclick= function(){
    const oldValStr= valSpan.textContent.replace(/[^\d.-]/g,'');
    const oldVal= parseFloat(oldValStr)||0;
    valSpan.onclick=null;
    valSpan.innerHTML='';

    const inp= document.createElement('input');
    inp.type='text';
    inp.value= oldValStr||'0';
    setTimeout(()=>inp.select(),0);

    inp.onblur= ()=> finishPortfolioValueEdit(inp.value, oldVal);
    inp.onkeydown= (ev)=>{
      if(ev.key==='Enter'){
        ev.preventDefault();
        inp.blur();
      }
    };
    valSpan.appendChild(inp);
    inp.focus();
  };

  function finishPortfolioValueEdit(newStr, oldVal){
    let newVal= parseFloat(newStr)||0;
    // If user typed zero or negative, revert to oldVal
    if(newVal <= 0) newVal= oldVal;

    // If it changed significantly, scale all asset amounts
    if(Math.abs(newVal - oldVal)> 0.00001 && oldVal>0){
      let scale= newVal/ oldVal;
      totalPortfolioValue= newVal;

      // scale each row's dollar fields
      assets.forEach(a=>{
        a.currentDollar *= scale;
        a.targetDollar  *= scale;
        // We also scale finalDollar & proposedDollar to keep distribution
        a.proposedDollar*= scale;
        a.finalDollar   *= scale;

        // Now recalc the % fields
        a.currentPct= (a.currentDollar/ newVal)*100;
        a.targetPct=  (a.targetDollar/  newVal)*100;
        a.proposedPct=(a.proposedDollar/ newVal)*100;
        a.finalPct=   (a.finalDollar/   newVal)*100;
      });
      // Re-render the table
      renderTableAndCharts();
    }

    // restore single-click
    valSpan.textContent= formatMoney(newVal);
    valSpan.onclick= enablePortfolioValueEdit; // rebind
  }
})();

/** Rounds Delta(%) to 0.01, replacing negative zero with "0.00". */
function roundDeltaPct(value){
  let r= parseFloat(value.toFixed(2));
  if(Math.abs(r)<0.005) r=0;
  return r.toFixed(2);
}

/** Color a cell red if val>0, green if val<0, else black. */
function colorDeltaCell(td, val){
  td.classList.remove('delta-positive','delta-negative');
  if(val> 0) td.classList.add('delta-positive');
  else if(val<0) td.classList.add('delta-negative');
}

/** Chart updates: left= target, right= final. */
function updateCharts(){
  const tarVals= assets.map(a=> a.targetDollar);
  const finVals= assets.map(a=> a.finalDollar);
  const labels= assets.map(a=> a.name);

  targetChart.data.labels= labels;
  targetChart.data.datasets[0].data= tarVals;
  targetChart.update();

  finalChart.data.labels= labels;
  finalChart.data.datasets[0].data= finVals;
  finalChart.update();
}

/** Format money with thousands separators and 2 decimals. */
function formatMoney(x){
  return new Intl.NumberFormat('en-US',{
    minimumFractionDigits:2,
    maximumFractionDigits:2
  }).format(x);
}

/** Initialize charts. */
function initCharts(){
  targetChart= new Chart(document.getElementById('targetChart'),{
    type:'pie',
    data:{
      labels:[],
      datasets:[{
        label:'Target Allocation',
        data:[],
        backgroundColor:['#2196f3','#8bc34a','#ffc107']
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:true,
      plugins:{ legend:{ position:'bottom' }}
    }
  });

  finalChart= new Chart(document.getElementById('finalChart'),{
    type:'pie',
    data:{
      labels:[],
      datasets:[{
        label:'Final Allocation',
        data:[],
        backgroundColor:['#2196f3','#8bc34a','#ffc107']
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:true,
      plugins:{ legend:{ position:'bottom' }}
    }
  });
}

/** On DOM load. */
window.addEventListener('DOMContentLoaded', ()=>{
  initCharts();

  document.getElementById('newClientBtn').addEventListener('click', newRandomClient);
  document.getElementById('resetTradesBtn').addEventListener('click', doResetTrades);

  // Generate first scenario
  newRandomClient();
});
</script>
</body>
</html>
