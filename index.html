<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Professional Portfolio Rebalancing Tool - Simulate and optimize your investment portfolio allocation">
  <meta name="theme-color" content="#007bff">
  <link rel="icon" type="image/png" href="favicon.png">
  <title>Portfolio Rebalancer Pro</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@9.4.4/lib/browser/math.js"></script>
  <style>
    :root {
      --primary-color: #007bff;
      --primary-hover: #0056b3;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --warning-color: #ffc107;
      --bg-body: #f8f9fa;
      --bg-container: #fff;
      --text-color: #212529;
      --header-footer-bg: #e9ecef;
      --asset-col-bg: #f8f9fa;
      --proposed-col-border: var(--primary-color);
      --editable-field-border: #dee2e6;
      --border-color: #dee2e6;
      --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
      --transition-speed: 0.3s;
    }
    body.dark-mode {
      --bg-body: #202020;
      --bg-container: #2c2c2c;
      --text-color: #eee;
      --header-footer-bg: #444;
      --asset-col-bg: #333;
      --proposed-col-border: #66afff;
      --editable-field-border: #888;
    }
    body {
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-width: 1200px;
      background: var(--bg-body);
      color: var(--text-color);
      transition: background var(--transition-speed), color var(--transition-speed);
      line-height: 1.5;
    }
    .container {
      width: 95%;
      max-width: 1400px;
      margin: 2rem auto;
      padding: 2rem;
      background: var(--bg-container);
      border-radius: 8px;
      box-shadow: var(--shadow-md);
      transition: background var(--transition-speed), color var(--transition-speed);
    }
    h1, h2 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-weight: 600;
      color: var(--text-color);
    }
    h1 {
      font-size: 2rem;
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 0.5rem;
    }
    h2 {
      font-size: 1.5rem;
    }

    .dark-mode-toggle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-container);
      position: fixed;
      top: 20px;
      right: 20px;
      cursor: pointer;
      border: 2px solid var(--border-color);
      transition: all var(--transition-speed);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow-sm);
    }
    .dark-mode-toggle i {
      font-size: 1.2rem;
      color: var(--text-color);
    }
    .dark-mode-toggle:hover {
      transform: scale(1.1);
      box-shadow: var(--shadow-md);
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      background: var(--primary-color);
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
      margin-left: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all var(--transition-speed);
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .btn:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
      box-shadow: var(--shadow-sm);
    }
    .btn i {
      font-size: 1rem;
    }
    .btn-danger {
      background: var(--danger-color);
    }
    .btn-danger:hover {
      background: #c82333;
    }
    .btn-success {
      background: var(--success-color);
    }
    .btn-success:hover {
      background: #218838;
    }

    .section {
      margin-bottom: 2rem;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 1.5rem;
    }
    .section:last-child {
      border-bottom: none;
    }

    /* Profile layout */
    #client-profile {
      display: flex; 
      justify-content: space-between; 
      flex-wrap: wrap;
    }
    .profile-info {
      flex: 1; 
      min-width: 320px; 
      margin-right: 1rem;
    }
    .profile-actions { 
      margin-top: 1rem; 
    }
    #riskSelect { 
      margin-left: 0.5rem; 
    }
    /* Numeric input for Cash Target (%) */
    #cashTargetInput {
      width: 50px;
      text-align: right;
      margin-left: 0.5rem;
    }

    /* Table & expansions */
    table {
      width: 100%;
      table-layout: fixed; 
      border-collapse: collapse;
      margin: 0.5rem 0;
      transition: background 0.3s, color 0.3s;
    }
    thead th {
      background: var(--header-footer-bg);
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      padding: 0.5rem 0.3rem;
    }
    th, td {
      padding: 0.3rem 0.3rem;
      border-bottom: 1px solid #eee;
      vertical-align: middle;
      text-align: right;  
      white-space: nowrap;
      font-size: 0.85rem;
      overflow: visible;  /* Changed from hidden to visible */
    }
    /* 11 columns: Name + 5 for dollars + 5 for percents */
    thead th:nth-child(1)  { width: 16%; text-align: left; }
    thead th:nth-child(2)  { width: 9%; }
    thead th:nth-child(3)  { width: 9%; }
    thead th:nth-child(4)  { width: 9%; }
    thead th:nth-child(5)  { width: 9%; }
    thead th:nth-child(6)  { width: 9%; }
    thead th:nth-child(7)  { width: 7%; }
    thead th:nth-child(8)  { width: 7%; }
    thead th:nth-child(9)  { width: 8%; }
    thead th:nth-child(10) { width: 8%; }
    thead th:nth-child(11) { width: 8%; }

    th:first-child, td:first-child {
      text-align: left; 
    }

    /* Make the monetary value cells wider to display full amounts */
    td:nth-child(2), td:nth-child(3), td:nth-child(4), td:nth-child(5), td:nth-child(6) {
      min-width: 85px;
    }

    .asset-col {
      background: var(--asset-col-bg);
      font-weight: bold;
      transition: background 0.3s;
    }
    .proposed-col {
      border: 1px dotted var(--proposed-col-border);
      background: #fafafa;
      cursor: pointer;
      transition: border-color 0.3s;
    }
    body.dark-mode .proposed-col { 
      background: #333; 
    }
    .proposed-positive { 
      color: green; 
      font-weight: bold; 
    }
    .proposed-negative { 
      color: red; 
      font-weight: bold; 
    }

    /* Delta => negative => red, positive => green, zero => black. */
    .delta-positive { 
      color: green; 
      font-weight: bold; 
    }
    .delta-negative { 
      color: red; 
      font-weight: bold; 
    }

    .expand-toggle {
      cursor: pointer; 
      color: #007bff; 
      margin-right: 0.5rem;
    }
    .class-row td { 
      padding-left: 2em; 
    }
    .position-row td { 
      padding-left: 4em; 
    }
    .subtotal-row td {
      font-weight: bold; 
      background: #f0f0f0;
    }

    .total-row {
      background: var(--header-footer-bg);
      font-weight: bold;
      text-align: right;
    }
    .total-row td {
      border-top: 2px solid #ccc;
      padding: 8px;
    }

    /* Charts */
    .charts-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }
    .chart-box {
      background: var(--bg-container);
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-speed);
      position: relative;
      overflow: hidden;
    }
    .chart-box:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    .chart-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--text-color);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .chart-title i {
      color: var(--primary-color);
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    .chart-loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    .chart-loading::after {
      content: '';
      width: 40px;
      height: 40px;
      border: 3px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Tooltips */
    [data-tooltip] {
      position: relative;
      cursor: help;
    }
    [data-tooltip]:before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem;
      background: var(--bg-container);
      color: var(--text-color);
      border-radius: 4px;
      font-size: 0.85rem;
      white-space: nowrap;
      box-shadow: var(--shadow-md);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-speed);
      z-index: 1000;
    }
    [data-tooltip]:hover:before {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-8px);
    }
    [data-tooltip]:after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: var(--bg-container);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-speed);
    }
    [data-tooltip]:hover:after {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-2px);
    }

    /* Responsive design */
    @media (max-width: 1200px) {
      body {
        min-width: auto;
      }
      .container {
        width: 100%;
        margin: 0;
        border-radius: 0;
      }
      .charts-container {
        grid-template-columns: 1fr;
      }
      table {
        display: block;
        overflow-x: auto;
        white-space: nowrap;
      }
    }
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      .btn {
        width: 100%;
        margin: 0.5rem 0;
        justify-content: center;
      }
    }

    .footer {
      text-align: center; 
      margin-top: 2rem; 
      font-size: 0.85rem; 
      transition: color 0.3s;
      color: var(--text-color);
    }
    .success { 
      color: green; 
      font-weight: bold; 
    }
    .error { 
      color: red;   
      font-weight: bold; 
    }
  </style>
</head>
<body>

<div class="dark-mode-toggle" id="darkModeToggle">
  <i class="fas fa-moon"></i>
</div>

<div class="container">
  <h1>Portfolio Manager Simulator – Phase 2 (Asset/Class-Level Trades)</h1>

  <!-- Client Profile -->
  <div class="section" id="client-profile">
    <div class="profile-info">
      <p><strong>Name:</strong> <span id="clientName">--</span></p>
      <p>
        <strong>Risk Tolerance:</strong>
        <select id="riskSelect">
          <option value="conservative">Conservative</option>
          <option value="moderate" selected>Moderate</option>
          <option value="aggressive">Aggressive</option>
        </select>
      </p>
      <p>
        <strong>Portfolio Value:</strong>
        $<span id="clientValue" class="editable-field">0</span>
      </p>
      <p>
        <strong>Target Allocation:</strong>
        <span id="targetStocks">--</span>% Stocks, 
        <span id="targetBonds">--</span>% Bonds, 
        <span id="targetCash">--</span>% Cash
      </p>
      <p>
        <strong>Cash Target (%):</strong>
        <input type="number" id="cashTargetInput" value="10" min="0" max="100" step="1"/>
      </p>
      <div class="profile-actions">
        <button class="btn" id="newClientBtn"><i class="fas fa-user-plus"></i> Generate New Client</button>
        <button class="btn" id="rebalanceBtn"><i class="fas fa-balance-scale"></i> Rebalance</button>
      </div>
    </div>
  </div>

  <!-- Table & Charts -->
  <div class="section">
    <div class="portfolio-header">
      <h2>Current (or Projected) Portfolio</h2>
      <div class="portfolio-buttons">
        <button class="btn" id="resetTradesBtn"><i class="fas fa-undo"></i> Reset Trades</button>
      </div>
    </div>

    <table id="portfolioTable">
      <thead>
        <tr>
          <th>Asset/Class/Position</th>
          <th>Current ($)</th>
          <th>Target ($)</th>
          <th>Delta ($)</th>
          <th>Proposed ($)</th>
          <th>Total ($)</th>
          <th>Current (%)</th>
          <th>Target (%)</th>
          <th>Delta (%)</th>
          <th>Proposed (%)</th>
          <th>Total (%)</th>
        </tr>
      </thead>
      <tbody id="portfolioRows"></tbody>
    </table>

    <div class="charts-container">
      <div class="chart-box">
        <div class="chart-title"><i class="fas fa-chart-pie"></i> Current Allocation</div>
        <div class="chart-container">
          <canvas id="currentChart"></canvas>
        </div>
      </div>
      <div class="chart-box">
        <div class="chart-title"><i class="fas fa-bullseye"></i> Target Allocation</div>
        <div class="chart-container">
          <canvas id="targetChart"></canvas>
        </div>
      </div>
      <div class="chart-box">
        <div class="chart-title"><i class="fas fa-check-circle"></i> Total Allocation</div>
        <div class="chart-container">
          <canvas id="finalChart"></canvas>
        </div>
      </div>
      <div class="chart-box">
        <div class="chart-title"><i class="fas fa-chart-line"></i> Risk Metrics</div>
        <div class="chart-container">
          <canvas id="riskMetricsChart"></canvas>
        </div>
      </div>
    </div>

    <p id="tradeMessage"></p>
  </div>
</div>

<div class="footer">
  &copy; Example – Phase 2 Asset/Class Proposed
</div>

<script>
/***************************************************************
 * Data Model
 ***************************************************************/
let root = {
  name: "ROOT",
  expanded: true,
  children: []
};
let originalData = null;

let clientName = "";
let totalPortfolioValue = 0;
let originalPortfolioValue = 0;

// Default risk => moderate
let userStockPct = 0.5, userBondPct = 0.4, userCashPct = 0.1;

let currentChart, targetChart, finalChart;

/***************************************************************
 * Dark Mode Toggle
 ***************************************************************/
const darkToggle = document.getElementById('darkModeToggle');
darkToggle.addEventListener('click', () => {
  const isDarkMode = document.body.classList.toggle('dark-mode');
  // Update icon
  const icon = darkToggle.querySelector('i');
  if (isDarkMode) {
    icon.className = 'fas fa-sun';
  } else {
    icon.className = 'fas fa-moon';
  }
  
  // Store preference
  localStorage.setItem('darkMode', isDarkMode);
});

// Check for saved dark mode preference
window.addEventListener('DOMContentLoaded', () => {
  const savedDarkMode = localStorage.getItem('darkMode');
  if (savedDarkMode === 'true') {
    document.body.classList.add('dark-mode');
    darkToggle.querySelector('i').className = 'fas fa-sun';
  }
});

/***************************************************************
 * Assign Parents (for bubble-up logic)
 ***************************************************************/
function assignParents(node, parent = null) {
  node.parent = parent;
  if (node.children && node.children.length > 0) {
    node.children.forEach(ch => assignParents(ch, node));
  }
}

/***************************************************************
 * Generate Random Data (All nodes expanded by default)
 ***************************************************************/
function generateRandomNestedData() {
  root.children = [];

  let stocks = { 
    name: "Stocks", 
    isAsset: true, 
    expanded: true, 
    children: [],
    volatility: 0.20,           // 20% annual volatility
    expectedReturn: 0.10,       // 10% expected return
    beta: 1.0                   // Market beta
  };
  
  let bonds = { 
    name: "Bonds",  
    isAsset: true, 
    expanded: true, 
    children: [],
    volatility: 0.05,           // 5% annual volatility  
    expectedReturn: 0.04,       // 4% expected return
    beta: 0.2                   // Lower beta than stocks
  };
  
  let cash = { 
    name: "Cash",   
    isAsset: true, 
    expanded: true, 
    children: [],
    volatility: 0.01,           // 1% annual volatility
    expectedReturn: 0.02,       // 2% expected return
    beta: 0.0                   // No correlation with market
  };

  stocks.children.push({
    name: "Large Cap", 
    isClass: true, 
    expanded: true, 
    children: [
      makePosition("AAPL", 0.25, 0.12, 1.2), // Higher volatility tech stock
      makePosition("MSFT", 0.22, 0.10, 1.1)  // Slightly lower volatility tech stock
    ]
  });
  stocks.children.push({
    name: "Small Cap", 
    isClass: true, 
    expanded: true, 
    children: [
      makePosition("RGEN", 0.35, 0.15, 1.5), // Higher volatility small cap
      makePosition("FIZZ", 0.28, 0.11, 1.3)  // Still higher volatility than large caps
    ]
  });

  bonds.children.push(makePosition("Corp Bond A", 0.06, 0.05, 0.3));
  bonds.children.push(makePosition("Gov Bond B", 0.03, 0.03, 0.1));

  cash.currentDollar = roundTo100(3000 + Math.random() * 2000);
  cash.targetDollar  = 0; 

  root.children.push(stocks, bonds, cash);
}

function makePosition(ticker, volatility = 0.2, expectedReturn = 0.08, beta = 1.0) {
  let cur = 3000 + Math.random() * 9000;
  let tar = cur + (Math.random() - 0.5) * 2000;
  return {
    name: ticker,
    isPosition: true,
    expanded: true,
    currentDollar: roundTo100(cur),
    targetDollar:  roundTo100(tar),
    proposedDollar: 0,
    totalDollar: 0,
    volatility: volatility,           // Annual volatility
    expectedReturn: expectedReturn,   // Expected annual return
    beta: beta,                       // Market beta
    costBasis: roundTo100(cur * 0.8), // 80% of current value as cost basis
    holdingPeriod: Math.floor(Math.random() * 500) // Random holding period up to 500 days
  };
}

function roundTo100(x) {
  return Math.round(x / 100) * 100;
}

/***************************************************************
 * Aggregation (bottom-up)
 ***************************************************************/
function aggregateNode(node) {
  if (!node.children || node.children.length === 0) {
    // For leaf nodes, total = current + proposed
    node.totalDollar = (node.currentDollar || 0) + (node.proposedDollar || 0);
    return;
  }
  
  // For parent nodes, sum up values from children
  let c = 0, t = 0, p = 0, tot = 0;
  node.children.forEach(ch => {
    aggregateNode(ch);
    c   += ch.currentDollar   || 0;
    t   += ch.targetDollar    || 0;
    p   += ch.proposedDollar  || 0;
    tot += ch.totalDollar     || 0;
  });
  
  node.currentDollar   = c;
  node.targetDollar    = t;
  node.proposedDollar  = p;
  node.totalDollar     = tot;
}

/***************************************************************
 * Compute Percentages
 ***************************************************************/
function computePercentages(node, rootRef) {
  let denom = (rootRef.targetDollar > 0 ? rootRef.targetDollar : 1);
  node.currentPct   = (node.currentDollar   / denom) * 100;
  node.targetPct    = (node.targetDollar    / denom) * 100;
  node.totalPct     = (node.totalDollar     / denom) * 100;
  node.proposedPct  = (node.proposedDollar / denom) * 100;

  if (node.children && node.children.length > 0) {
    node.children.forEach(ch => computePercentages(ch, rootRef));
  }
}

/***************************************************************
 * Distribute Proposed($) Down
 * Based on child.currentDollar ratio
 ***************************************************************/
function distributeProposedDown(node) {
  if (!node.children || node.children.length === 0) return;
  
  // Get the sum of current dollars for all children
  let sumCur = node.children.reduce((acc, ch) => acc + (ch.currentDollar || 0), 0);
  if (sumCur < 1) sumCur = 1;
  
  // Log the distribution process for debugging
  console.log(`Distributing ${node.proposedDollar} for ${node.name} among ${node.children.length} children`);
  
  // Distribute proposed dollars to children based on their current proportion
  node.children.forEach(ch => {
    // Calculate the ratio of this child's current value to the total
    let ratio = (ch.currentDollar || 0) / sumCur;
    
    // Apply the same ratio to the proposed value
    ch.proposedDollar = ratio * node.proposedDollar;
    
    console.log(`  Child ${ch.name}: Current $${ch.currentDollar}, Ratio ${ratio.toFixed(4)}, Proposed $${ch.proposedDollar.toFixed(2)}`);
    
    // Recursively distribute to this child's children if any
    distributeProposedDown(ch);
  });
}

/***************************************************************
 * Bubble Proposed($) Up
 * Sum children's Proposed($) => parent's Proposed($)
 ***************************************************************/
function bubbleUpProposed(node) {
  if (!node.parent) return;
  let siblings = node.parent.children;
  let total = siblings.reduce((acc, ch) => acc + (ch.proposedDollar || 0), 0);
  node.parent.proposedDollar = total;
  bubbleUpProposed(node.parent);
}

/***************************************************************
 * Set Proposed($) for a node
 * - If node has children => distributeProposedDown
 * - Otherwise => bubbleUpProposed
 * - Then re-render
 ***************************************************************/
function applyProposedValue(node, val) {
  node.proposedDollar = val;

  if (node.children && node.children.length > 0) {
    // top-down distribution
    distributeProposedDown(node);
  }
  // bottom-up update
  bubbleUpProposed(node);

  renderAll();
}

/***************************************************************
 * Table Rendering
 ***************************************************************/
function renderTable() {
  const tb = document.getElementById('portfolioRows');
  tb.innerHTML = "";
  root.children.forEach(asset => renderNode(asset, 0));
  buildTotalRow();
}

function renderNode(node, level) {
  const tr = document.createElement('tr');
  if (node.isClass)         tr.classList.add('class-row');
  else if (node.isPosition) tr.classList.add('position-row');
  else if (node.isAsset)    tr.classList.add('asset-row');

  let tdName = document.createElement('td');
  if (node.isAsset) {
    tdName.className = 'asset-col';
  }
  if (node.children && node.children.length > 0) {
    let toggler = document.createElement('span');
    toggler.className = 'expand-toggle';
    toggler.textContent = node.expanded ? "▼" : "▶";
    toggler.onclick = () => {
      node.expanded = !node.expanded;
      renderAll();
    };
    tdName.appendChild(toggler);
  }
  tdName.appendChild(document.createTextNode(node.name));
  tr.appendChild(tdName);

  // 1) Current($)
  let tdCur = document.createElement('td');
  tdCur.textContent = formatMoney(node.currentDollar || 0);
  tr.appendChild(tdCur);

  // 2) Target($)
  let tdTar = document.createElement('td');
  tdTar.textContent = formatMoney(node.targetDollar || 0);
  tr.appendChild(tdTar);

  // 3) Delta($) => (target - total)
  let dval = (node.targetDollar || 0) - (node.totalDollar || 0);
  let tdDelta = document.createElement('td');
  tdDelta.textContent = withSignMoney(dval);
  colorDeltaCell(tdDelta, dval);
  tr.appendChild(tdDelta);

  // 4) Proposed($)
  let tdProp = document.createElement('td');
  tdProp.className = 'proposed-col';
  let pd = node.proposedDollar || 0;
  // highlight positive/negative
  if (Math.abs(pd) > 0.01) {
    if (pd > 0) tdProp.classList.add('proposed-positive');
    else        tdProp.classList.add('proposed-negative');
  }
  tdProp.textContent = formatMoney(pd);
  // user can click to edit Proposed($)
  tdProp.onclick = () => editProposedCell(tdProp, node, 'dollar');
  tr.appendChild(tdProp);

  // 5) Total($)
  let tdTot = document.createElement('td');
  tdTot.textContent = formatMoney(node.totalDollar || 0);
  tr.appendChild(tdTot);

  // 6) Current(%)
  let tdCurPct = document.createElement('td');
  tdCurPct.textContent = (node.currentPct || 0).toFixed(2) + "%";
  tr.appendChild(tdCurPct);

  // 7) Target(%)
  let tdTarPct = document.createElement('td');
  tdTarPct.textContent = (node.targetPct || 0).toFixed(2) + "%";
  tr.appendChild(tdTarPct);

  // 8) Delta(%)
  let dp = (node.targetPct || 0) - (node.totalPct || 0);
  let tdDeltaPct = document.createElement('td');
  tdDeltaPct.textContent = withSignPct(dp);
  colorDeltaCell(tdDeltaPct, dp);
  tr.appendChild(tdDeltaPct);

  // 9) Proposed(%)
  let tdPropPct = document.createElement('td');
  tdPropPct.className = 'proposed-col';
  let pp = node.proposedPct || 0;
  if (Math.abs(pp) > 0.01) {
    if (pp > 0) tdPropPct.classList.add('proposed-positive');
    else        tdPropPct.classList.add('proposed-negative');
  }
  tdPropPct.textContent = pp.toFixed(2) + "%";
  // user can click to edit Proposed(%)
  tdPropPct.onclick = () => editProposedCell(tdPropPct, node, 'percent');
  tr.appendChild(tdPropPct);

  // 10) Total(%)
  let tdTotPct = document.createElement('td');
  let tp = node.totalPct || 0;
  tdTotPct.textContent = tp.toFixed(2) + "%";
  tr.appendChild(tdTotPct);

  document.getElementById('portfolioRows').appendChild(tr);

  // If expanded, render children
  if (node.expanded && node.children && node.children.length > 0) {
    node.children.forEach(ch => renderNode(ch, level + 1));
  }
}

function buildTotalRow() {
  const tb = document.getElementById('portfolioRows');

  let cDollar   = root.currentDollar   || 0;
  let tDollar   = root.targetDollar    || 0;
  let pDollar   = root.proposedDollar  || 0;
  let totDollar = root.totalDollar     || 0;

  let dval = tDollar - totDollar; 
  let dpct = (root.targetPct || 0) - (root.totalPct || 0);

  let tr = document.createElement('tr');
  tr.classList.add('total-row');

  let tdLabel = document.createElement('td');
  tdLabel.textContent = "Total Portfolio";
  tr.appendChild(tdLabel);

  let tdCurr = document.createElement('td');
  tdCurr.textContent = formatMoney(cDollar);
  tr.appendChild(tdCurr);

  let tdTarg = document.createElement('td');
  tdTarg.textContent = formatMoney(tDollar);
  tr.appendChild(tdTarg);

  let tdDelta = document.createElement('td');
  tdDelta.textContent = withSignMoney(dval);
  colorDeltaCell(tdDelta, dval);
  tr.appendChild(tdDelta);

  let tdProp = document.createElement('td');
  tdProp.textContent = formatMoney(pDollar);
  tr.appendChild(tdProp);

  let tdTot = document.createElement('td');
  tdTot.textContent = formatMoney(totDollar);
  tr.appendChild(tdTot);

  let tdCurrPct = document.createElement('td');
  tdCurrPct.textContent = (root.currentPct || 0).toFixed(2) + "%";
  tr.appendChild(tdCurrPct);

  let tdTargPct = document.createElement('td');
  tdTargPct.textContent = (root.targetPct || 0).toFixed(2) + "%";
  tr.appendChild(tdTargPct);

  let tdDeltaPct = document.createElement('td');
  tdDeltaPct.textContent = withSignPct(dpct);
  colorDeltaCell(tdDeltaPct, dpct);
  tr.appendChild(tdDeltaPct);

  let tdPropPct = document.createElement('td');
  tdPropPct.textContent = (root.proposedPct || 0).toFixed(2) + "%";
  tr.appendChild(tdPropPct);

  let tdTotPct = document.createElement('td');
  tdTotPct.textContent = (root.totalPct || 0).toFixed(2) + "%";
  tr.appendChild(tdTotPct);

  tb.appendChild(tr);
}

/***************************************************************
 * Proposed Cell Editing => Single-click
 ***************************************************************/
function editProposedCell(cell, node, mode) {
  let oldVal = cell.textContent.replace(/,/g, '').replace(/[^\d.\-+]/g, '');
  cell.onclick = null;
  cell.innerHTML = '';

  let input = document.createElement('input');
  input.type = 'text';
  input.value = oldVal || '0';
  setTimeout(() => input.select(), 0);

  input.onblur = () => finishProposedEdit(cell, node, input.value, mode);
  input.onkeydown = (ev) => {
    if (ev.key === 'Enter') {
      ev.preventDefault();
      input.blur();
    }
  };
  cell.appendChild(input);
  input.focus();
}

function finishProposedEdit(cell, node, rawVal, mode) {
  rawVal = rawVal.replace(/,/g, '');
  let val = parseFloat(rawVal);
  if (isNaN(val)) val = 0;

  // Proposed(%) -> fraction of root.targetDollar
  if (mode === 'percent') {
    // clamp if too large in demonstration
    if (val > 200) val = 200;
    let rt = (root.targetDollar > 0 ? root.targetDollar : 1);
    applyProposedValue(node, (val / 100) * rt);
  } else {
    // Proposed($): clamp if over 2x total portfolio
    if (val > 2 * totalPortfolioValue) {
      val = 2 * totalPortfolioValue;
    }
    applyProposedValue(node, val);
  }
}

/***************************************************************
 * Recalc & Rerender
 ***************************************************************/
function renderAll() {
  try {
    // Step 1: Aggregate values from bottom up
    aggregateNode(root);
    
    // Step 2: Compute percentages
    computePercentages(root, root);
    
    // Update total portfolio value display
    document.getElementById('clientValue').textContent = formatMoney(totalPortfolioValue);
    
    // Step 3: Render the table
    renderTable();
    
    // Step 4: Update allocation charts
    updateCharts();
    
    // Step 5: Update analytics dashboard
    try {
      portfolioAnalytics.updateAnalyticsDashboard();
    } catch (analyticsError) {
      console.error('Error updating analytics dashboard:', analyticsError);
    }
    
    // Step 6: Update risk metrics chart if available
    try {
      if (window.riskMetricsChart) {
        const metrics = portfolioAnalytics.calculateRiskMetrics();
        riskMetricsChart.data.datasets[0].data = [
          metrics.volatility * 100,  // Scale to percentage
          metrics.beta,
          metrics.sharpeRatio,
          metrics.correlation
        ];
        riskMetricsChart.update();
      }
    } catch (chartError) {
      console.error('Error updating risk metrics chart:', chartError);
    }
  } catch (error) {
    console.error('Error in renderAll:', error);
    const messageElement = document.getElementById('tradeMessage');
    if (messageElement) {
      messageElement.textContent = "Error rendering portfolio: " + error.message;
      messageElement.className = "error";
    }
  }
}

/***************************************************************
 * Distributing Risk (Top-Down)
 ***************************************************************/
function applyRiskAllocation() {
  let tVal = totalPortfolioValue;
  let stocksVal = userStockPct * tVal;
  let bondsVal  = userBondPct  * tVal;
  let cashVal   = userCashPct  * tVal;

  root.children.forEach(ch => {
    if (/stock/i.test(ch.name)) {
      ch.targetDollar = stocksVal;
    } else if (/bond/i.test(ch.name)) {
      ch.targetDollar = bondsVal;
    } else if (/cash/i.test(ch.name)) {
      ch.targetDollar = cashVal;
    } else {
      ch.targetDollar = 0; 
    }
  });
  root.children.forEach(ch => distributeTargets(ch));
}

function distributeTargets(node) {
  if (!node.children || node.children.length === 0) return;
  let totalCur = node.children.reduce((acc, c) => acc + (c.currentDollar || 0), 0);
  if (totalCur < 1) totalCur = 1; 
  node.children.forEach(ch => {
    let ratio = (ch.currentDollar || 0) / totalCur;
    ch.targetDollar = node.targetDollar * ratio;
    distributeTargets(ch);
  });
}

/***************************************************************
 * SHIFTING RISK on <select>
 ***************************************************************/
function onRiskChange() {
  let val = document.getElementById('riskSelect').value;
  if (val === "conservative") {
    userStockPct = 0.3; userBondPct = 0.5; userCashPct = 0.2;
  } else if (val === "aggressive") {
    userStockPct = 0.7; userBondPct = 0.2; userCashPct = 0.1;
  } else {
    userStockPct = 0.5; userBondPct = 0.4; userCashPct = 0.1;
  }
  document.getElementById('cashTargetInput').value = (userCashPct * 100).toFixed(0);

  document.getElementById('targetStocks').textContent = (userStockPct * 100).toFixed(0);
  document.getElementById('targetBonds').textContent  = (userBondPct * 100).toFixed(0);
  document.getElementById('targetCash').textContent   = (userCashPct * 100).toFixed(0);

  applyRiskAllocation();
  renderAll();
}

/***************************************************************
 * Handle Cash Target Change
 ***************************************************************/
function onCashTargetChange() {
  const cashTargetVal = parseFloat(document.getElementById('cashTargetInput').value) / 100;
  if (isNaN(cashTargetVal) || cashTargetVal < 0 || cashTargetVal > 1) {
    // Reset to previous value if invalid
    document.getElementById('cashTargetInput').value = (userCashPct * 100).toFixed(0);
    return;
  }
  
  // Update cash percentage
  userCashPct = cashTargetVal;
  
  // Adjust stocks and bonds proportionally
  const remainingPct = 1 - userCashPct;
  const currentRatio = userStockPct / (userStockPct + userBondPct);
  
  userStockPct = remainingPct * currentRatio;
  userBondPct = remainingPct * (1 - currentRatio);
  
  // Update display
  document.getElementById('targetStocks').textContent = (userStockPct * 100).toFixed(0);
  document.getElementById('targetBonds').textContent = (userBondPct * 100).toFixed(0);
  document.getElementById('targetCash').textContent = (userCashPct * 100).toFixed(0);
  
  applyRiskAllocation();
  renderAll();
}

/***************************************************************
 * Generating & Scaling to Match Portfolio Value
 ***************************************************************/
function doGenerateNewClient() {
  const names = ["John Smith","Jane Doe","Alex Johnson","Maria Garcia","Lee Wong"];
  let n = names[Math.floor(Math.random() * names.length)];
  clientName = n;
  document.getElementById('clientName').textContent = n;

  let val = 80000 + Math.random() * 40000;
  val = Math.round(val / 100) * 100;
  totalPortfolioValue = val;
  document.getElementById('clientValue').textContent = formatMoney(val);

  generateRandomNestedData();
  // assign parents for bubble-up logic
  assignParents(root, null);

  aggregateNode(root);
  let sumCur = root.currentDollar || 1;
  let ratio  = totalPortfolioValue / sumCur;
  scaleNode(root, ratio);
  aggregateNode(root);

  originalData = JSON.parse(JSON.stringify(root));
  originalPortfolioValue = val;

  applyRiskAllocation();
  renderAll();
}

function scaleNode(node, ratio) {
  if (!node.children || node.children.length === 0) {
    node.currentDollar = Math.round(node.currentDollar * ratio);
    node.targetDollar  = Math.round(node.targetDollar  * ratio);
    return;
  }
  node.children.forEach(ch => scaleNode(ch, ratio));
}

function doResetTrades() {
  if (originalData) {
    root = JSON.parse(JSON.stringify(originalData));
    totalPortfolioValue = originalPortfolioValue;
    document.getElementById('clientValue').textContent = formatMoney(totalPortfolioValue);
    // re-assign parents for the fresh copy
    assignParents(root, null);
    renderAll();
    document.getElementById('tradeMessage').textContent = "Reset to initial scenario.";
  }
}

/***************************************************************
 * Chart init & update
 ***************************************************************/
function initCharts() {
  currentChart = new Chart(document.getElementById('currentChart'), {
    type: 'pie',
    data: {
      labels: [], 
      datasets: [{
        label: 'Current',
        data: [],
        backgroundColor: ['#2196f3','#8bc34a','#ffc107','#ff5722']
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      plugins: { legend: { position: 'bottom' } }
    }
  });

  targetChart = new Chart(document.getElementById('targetChart'), {
    type: 'pie',
    data: {
      labels: [],
      datasets: [{
        label: 'Target',
        data: [],
        backgroundColor: ['#2196f3','#8bc34a','#ffc107','#ff5722']
      }]
    },
    options: { 
      responsive: true,
      maintainAspectRatio: true,
      plugins: { legend: { position: 'bottom' } }
    }
  });

  finalChart = new Chart(document.getElementById('finalChart'), {
    type: 'pie',
    data: {
      labels: [],
      datasets: [{
        label: 'Total',
        data: [],
        backgroundColor: ['#2196f3','#8bc34a','#ffc107','#ff5722']
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      plugins: { legend: { position: 'bottom' } }
    }
  });
  
  // Add risk metrics chart
  window.riskMetricsChart = new Chart(document.getElementById('riskMetricsChart'), {
    type: 'radar',
    data: {
      labels: ['Volatility (%)', 'Beta', 'Sharpe Ratio', 'Correlation'],
      datasets: [{
        label: 'Portfolio Risk Metrics',
        data: [0, 0, 0, 0],
        backgroundColor: 'rgba(33, 150, 243, 0.2)',
        borderColor: '#2196f3',
        borderWidth: 2,
        pointBackgroundColor: '#2196f3',
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: '#2196f3'
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      scales: {
        r: {
          angleLines: {
            display: true
          },
          suggestedMin: 0,
          suggestedMax: 100
        }
      },
      plugins: { 
        legend: { 
          position: 'bottom'
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.dataset.label;
              const value = context.raw;
              const metricName = context.chart.data.labels[context.dataIndex];
              
              if (metricName === 'Volatility (%)') {
                return `${label}: ${value.toFixed(2)}%`;
              } else {
                return `${label}: ${value.toFixed(2)}`;
              }
            }
          }
        }
      }
    }
  });
}

function updateCharts() {
  let labels = [], curVals = [], tarVals = [], totVals = [];
  root.children.forEach(ch => {
    labels.push(ch.name);
    curVals.push(ch.currentDollar || 0);
    tarVals.push(ch.targetDollar || 0);
    totVals.push(ch.totalDollar || 0);
  });
  currentChart.data.labels = labels;
  currentChart.data.datasets[0].data = curVals;
  currentChart.update();

  targetChart.data.labels = labels;
  targetChart.data.datasets[0].data = tarVals;
  targetChart.update();

  finalChart.data.labels = labels;
  finalChart.data.datasets[0].data = totVals;
  finalChart.update();
}

/***************************************************************
 * Utility Functions
 ***************************************************************/
function formatMoney(x) {
  // Handle very large numbers (prevents truncation)
  if (Math.abs(x) >= 1000000) {
    return new Intl.NumberFormat('en-US', {
      style: 'decimal',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(x);
  }
  
  return new Intl.NumberFormat('en-US', {
    style: 'decimal',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(x);
}

function colorDeltaCell(td, val) {
  td.classList.remove('delta-positive', 'delta-negative');
  let r = parseFloat(val.toFixed(2));
  if (Math.abs(r) < 0.01) {
    // zero => no special color
  } else if (r < 0) {
    td.classList.add('delta-negative');
  } else {
    td.classList.add('delta-positive');
  }
}

function withSignMoney(value) {
  let r = parseFloat(value.toFixed(2));
  if (Math.abs(r) < 0.01) r = 0;
  let absVal = Math.abs(r);
  let absStr = formatMoney(absVal);
  if (r > 0)  return `+${absStr}`;
  if (r < 0)  return `-${absStr}`;
  return absStr;
}

function withSignPct(value) {
  let r = parseFloat(value.toFixed(2));
  if (Math.abs(r) < 0.01) r = 0;
  let absVal = Math.abs(r).toFixed(2);
  if (r > 0)  return `+${absVal}%`;
  if (r < 0)  return `-${absVal}%`;
  return "0.00%";
}

// Comprehensive utility object for use by new features
const utils = {
  formatCurrency: (value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(value);
  },
  formatPercent: (value) => {
    return new Intl.NumberFormat('en-US', {
      style: 'percent',
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }).format(value / 100);
  },
  validateNumber: (value, min, max) => {
    const num = Number(value);
    if (isNaN(num)) return false;
    return num >= min && num <= max;
  },
  showError: (message) => {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    errorDiv.style.position = 'fixed';
    errorDiv.style.top = '20px';
    errorDiv.style.left = '50%';
    errorDiv.style.transform = 'translateX(-50%)';
    errorDiv.style.backgroundColor = 'rgba(220, 53, 69, 0.9)';
    errorDiv.style.color = 'white';
    errorDiv.style.padding = '10px 20px';
    errorDiv.style.borderRadius = '4px';
    errorDiv.style.zIndex = '1000';
    document.body.appendChild(errorDiv);
    
    setTimeout(() => {
      errorDiv.style.opacity = '0';
      errorDiv.style.transition = 'opacity 0.5s';
      setTimeout(() => errorDiv.remove(), 500);
    }, 3000);
  },
  showLoading: (element) => {
    if (element) {
      element.classList.add('loading');
      element.disabled = true;
    }
  },
  hideLoading: (element) => {
    if (element) {
      element.classList.remove('loading');
      element.disabled = false;
    }
  }
};

/***************************************************************
 * Enable Editing of Portfolio Value (clientValue)
 ***************************************************************/
function enablePortfolioValueEdit() {
  const valElem = document.getElementById('clientValue');
  valElem.addEventListener('click', function onClick() {
    const oldVal = valElem.textContent.replace(/,/g, '').replace(/[^\d.\-+]/g, '');
    valElem.innerHTML = '';

    const input = document.createElement('input');
    input.type = 'text';
    input.value = oldVal || '0';

    input.onblur = function() {
      let parsed = parseFloat(input.value.replace(/,/g, '')) || 0;
      if (parsed < 1) parsed = 1;
      totalPortfolioValue = parsed;
      valElem.innerHTML = formatMoney(parsed);
      onRiskChange();
    };

    input.onkeydown = function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      }
    };

    valElem.appendChild(input);
    input.select();
  });
}

/***************************************************************
 * Handle Rebalance
 ***************************************************************/
function doRebalance() {
  try {
    // Reset proposed values
    resetProposedValues(root);
    
    // For each asset, set proposed value to the difference between target and current
    root.children.forEach(asset => {
      if (asset.isAsset) {
        // Calculate the exact delta needed to reach target
        const delta = asset.targetDollar - asset.currentDollar;
        asset.proposedDollar = delta;
        
        console.log(`Rebalancing ${asset.name}: Current $${asset.currentDollar}, Target $${asset.targetDollar}, Delta $${delta}`);
        
        // Distribute proposed values to children
        if (asset.children && asset.children.length > 0) {
          distributeProposedDown(asset);
        }
      }
    });
    
    // Re-render everything
    renderAll();
    
    document.getElementById('tradeMessage').textContent = "Rebalance trades have been proposed. Review trades above to bring your portfolio to the target allocation.";
    document.getElementById('tradeMessage').className = "success";
  } catch (error) {
    console.error('Error rebalancing portfolio:', error);
    document.getElementById('tradeMessage').textContent = "Error rebalancing portfolio: " + error.message;
    document.getElementById('tradeMessage').className = "error";
  }
}

function resetProposedValues(node) {
  node.proposedDollar = 0;
  if (node.children && node.children.length > 0) {
    node.children.forEach(resetProposedValues);
  }
}

/***************************************************************
 * Startup
 ***************************************************************/
window.addEventListener('DOMContentLoaded', () => {
  // Initialize charts first
  initCharts();
  enablePortfolioValueEdit();

  // Set up event listeners
  document.getElementById('riskSelect').addEventListener('change', onRiskChange);
  document.getElementById('cashTargetInput').addEventListener('change', onCashTargetChange);
  document.getElementById('cashTargetInput').addEventListener('input', onCashTargetChange);
  document.getElementById('newClientBtn').addEventListener('click', doGenerateNewClient);
  document.getElementById('resetTradesBtn').addEventListener('click', doResetTrades);
  document.getElementById('rebalanceBtn').addEventListener('click', doRebalance);

  // Initial data generation
  generateRandomNestedData();
  // Assign parents for bubble-up logic
  assignParents(root, null);
  
  // Set initial portfolio value
  totalPortfolioValue = 100000;
  document.getElementById('clientValue').textContent = formatMoney(totalPortfolioValue);
  
  // Initialize risk profile display
  document.getElementById('targetStocks').textContent = (userStockPct * 100).toFixed(0);
  document.getElementById('targetBonds').textContent = (userBondPct * 100).toFixed(0);
  document.getElementById('targetCash').textContent = (userCashPct * 100).toFixed(0);
  
  // Apply initial risk allocation
  applyRiskAllocation();
  
  // Do initial render
  renderAll();
  
  // Then generate a complete client scenario
  doGenerateNewClient();
});

// Financial Constants
const FINANCIAL_CONSTANTS = {
  REBALANCING_THRESHOLDS: {
    conservative: 0.05,  // 5% deviation triggers rebalance
    moderate: 0.10,      // 10% deviation triggers rebalance
    aggressive: 0.15     // 15% deviation triggers rebalance
  },
  TAX_RATES: {
    shortTerm: 0.37,  // Short-term capital gains
    longTerm: 0.20,   // Long-term capital gains
    qualified: 0.15   // Qualified dividends
  },
  RISK_FREE_RATE: 0.02,  // 2% risk-free rate
  MARKET_RETURN: 0.08,   // 8% expected market return
  MIN_HOLDING_PERIOD: 365 // Days for long-term capital gains
};

// Portfolio Analytics
const portfolioAnalytics = {
  calculateRiskMetrics() {
    try {
      const metrics = {
        sharpeRatio: 0,
        volatility: 0,
        beta: 0,
        correlation: 0
      };
      
      // Calculate portfolio volatility and expected return
      let totalWeight = 0;
      let weightedVol = 0;
      let weightedReturn = 0;
      let weightedBeta = 0;
      
      // Default minimum values to avoid division by zero
      const minVol = 0.01;
      const minReturn = 0.01;
      
      root.children.forEach(asset => {
        if (asset.isAsset) {
          // Use current dollar amount for weight calculation
          const weight = asset.currentDollar / totalPortfolioValue;
          
          // Ensure reasonable defaults if values are missing
          const assetVol = Math.max(minVol, asset.volatility || 0.05);
          const assetReturn = Math.max(minReturn, asset.expectedReturn || 0.03);
          const assetBeta = asset.beta || 0.5;
          
          weightedVol += weight * assetVol;
          weightedReturn += weight * assetReturn;
          weightedBeta += weight * assetBeta;
          totalWeight += weight;
        }
      });
      
      // Normalize if weights don't sum to 1 (which they should)
      if (totalWeight > 0 && Math.abs(totalWeight - 1) > 0.01) {
        weightedVol /= totalWeight;
        weightedReturn /= totalWeight;
        weightedBeta /= totalWeight;
      }
      
      // Ensure minimum values
      weightedVol = Math.max(minVol, weightedVol);
      weightedReturn = Math.max(minReturn, weightedReturn);
      
      // Calculate Sharpe ratio - (portfolio return - risk free rate) / portfolio volatility
      const riskFreeRate = FINANCIAL_CONSTANTS.RISK_FREE_RATE;
      metrics.sharpeRatio = (weightedReturn - riskFreeRate) / weightedVol;
      metrics.volatility = weightedVol;
      metrics.beta = weightedBeta;
      metrics.correlation = 0.75; // Placeholder - would normally calculate from covariance matrix
      
      return metrics;
    } catch (error) {
      console.error('Error calculating risk metrics:', error);
      // Return default values on error
      return {
        sharpeRatio: 0.5,
        volatility: 0.1,
        beta: 1.0,
        correlation: 0.5
      };
    }
  },

  generateCorrelationMatrix() {
    const assets = root.children.filter(node => node.isAsset);
    const matrix = [];
    
    assets.forEach(asset1 => {
      const row = [];
      assets.forEach(asset2 => {
        const correlation = this.calculateCorrelation(asset1, asset2);
        row.push(correlation);
      });
      matrix.push(row);
    });
    
    return matrix;
  },

  calculateCorrelation(asset1, asset2) {
    // In a real app, this would use historical return data
    // For demo purposes, using pre-defined correlations
    if (asset1.name === asset2.name) return 1.0; // Perfect correlation with self
    
    // Typical stock-bond correlation is negative or low
    if ((asset1.name === "Stocks" && asset2.name === "Bonds") || 
        (asset1.name === "Bonds" && asset2.name === "Stocks")) {
      return -0.2;
    }
    
    // Stocks and cash tend to have very low correlation
    if ((asset1.name === "Stocks" && asset2.name === "Cash") || 
        (asset1.name === "Cash" && asset2.name === "Stocks")) {
      return 0.1;
    }
    
    // Bonds and cash have positive but low correlation
    if ((asset1.name === "Bonds" && asset2.name === "Cash") || 
        (asset1.name === "Cash" && asset2.name === "Bonds")) {
      return 0.3;
    }
    
    // Default correlation for other asset pairs
    return 0.5;
  },

  optimizePortfolio() {
    // In a real app, this would use quadratic programming to optimize
    // For this demo, we'll use a simplified approach
    const assets = root.children.filter(node => node.isAsset);
    
    // Step 1: Calculate risk-adjusted returns (Sharpe ratio for each asset)
    const riskAdjustedReturns = assets.map(asset => {
      const vol = asset.volatility || 0.05;
      const ret = asset.expectedReturn || 0.03;
      const riskFreeRate = FINANCIAL_CONSTANTS.RISK_FREE_RATE;
      return vol > 0 ? (ret - riskFreeRate) / vol : 0;
    });
    
    // Step 2: Normalize to get weights that favor higher risk-adjusted returns
    const sum = riskAdjustedReturns.reduce((a, b) => a + Math.max(0, b), 0);
    let weights;
    
    if (sum > 0) {
      weights = riskAdjustedReturns.map(rar => Math.max(0, rar) / sum);
    } else {
      // Fallback to equal weighting if all have negative risk-adjusted returns
      weights = assets.map(() => 1 / assets.length);
    }
    
    // Step 3: Reserve cash percentage
    if (userCashPct > 0) {
      const totalOtherWeight = 1 - userCashPct;
      
      // Find cash asset and set its weight
      const cashIndex = assets.findIndex(asset => asset.name === "Cash");
      if (cashIndex !== -1) {
        weights[cashIndex] = userCashPct;
        
        // Normalize other weights to sum to (1 - cashWeight)
        const nonCashWeightSum = weights.reduce((sum, w, i) => i !== cashIndex ? sum + w : sum, 0);
        
        if (nonCashWeightSum > 0) {
          weights = weights.map((w, i) => {
            if (i === cashIndex) return userCashPct;
            return (w / nonCashWeightSum) * totalOtherWeight;
          });
        }
      }
    }
    
    // Step 4: Apply optimal weights to portfolio
    assets.forEach((asset, index) => {
      asset.targetDollar = weights[index] * totalPortfolioValue;
    });
    
    // Update the UI to reflect the changes
    document.getElementById('targetStocks').textContent = 
      (weights[assets.findIndex(a => a.name === "Stocks")] * 100 || 0).toFixed(0);
    document.getElementById('targetBonds').textContent = 
      (weights[assets.findIndex(a => a.name === "Bonds")] * 100 || 0).toFixed(0);
    document.getElementById('targetCash').textContent = 
      (weights[assets.findIndex(a => a.name === "Cash")] * 100 || 0).toFixed(0);
    
    // Update the model and render
    applyRiskAllocation();
    renderAll();
  },

  checkRebalancingNeeded() {
    const threshold = FINANCIAL_CONSTANTS.REBALANCING_THRESHOLDS[document.getElementById('riskSelect').value] || 0.1;
    let needsRebalance = false;
    
    root.children.forEach(asset => {
      if (asset.isAsset) {
        // Check deviation using totalPortfolioValue to ensure correct percentage calculation
        const currentWeight = asset.currentDollar / totalPortfolioValue;
        const targetWeight = asset.targetDollar / totalPortfolioValue;
        const deviation = Math.abs(currentWeight - targetWeight);
        
        console.log(`Asset: ${asset.name}, Current: ${currentWeight.toFixed(4)}, Target: ${targetWeight.toFixed(4)}, Deviation: ${deviation.toFixed(4)}, Threshold: ${threshold}`);
        
        if (deviation > threshold) {
          needsRebalance = true;
        }
      }
    });
    
    // Always return true to allow rebalancing anytime the button is clicked
    return true;
  },

  calculateTaxImplications() {
    let taxImpact = 0;
    
    // Recursively process all positions
    const processNode = (node) => {
      if (node.isPosition) {
        const costBasis = node.costBasis || node.currentDollar * 0.8; // Default to 80% of current value
        const proposedSell = node.proposedDollar < 0 ? Math.abs(node.proposedDollar) : 0;
        
        if (proposedSell > 0) {
          // Calculate what portion of the sell amount is gain
          const sellRatio = proposedSell / node.currentDollar;
          const basisPortion = costBasis * sellRatio;
          const gain = proposedSell - basisPortion;
          
          if (gain > 0) {
            const holdingPeriod = node.holdingPeriod || 0;
            const taxRate = holdingPeriod > FINANCIAL_CONSTANTS.MIN_HOLDING_PERIOD 
              ? FINANCIAL_CONSTANTS.TAX_RATES.longTerm 
              : FINANCIAL_CONSTANTS.TAX_RATES.shortTerm;
            
            taxImpact += gain * taxRate;
          }
        }
      } else if (node.children) {
        node.children.forEach(child => processNode(child));
      }
    };
    
    // Start processing from root
    processNode(root);
    
    return taxImpact;
  },

  updateAnalyticsDashboard() {
    try {
      const metrics = this.calculateRiskMetrics();
      const taxImpact = this.calculateTaxImplications();
      const needsRebalance = this.checkRebalancingNeeded();
      
      // Create or update dashboard
      let dashboard = document.querySelector('.analytics-dashboard');
      
      if (!dashboard) {
        dashboard = document.createElement('div');
        dashboard.className = 'analytics-dashboard';
        
        // Add styles if not already in CSS
        if (!document.getElementById('analytics-dashboard-styles')) {
          const style = document.createElement('style');
          style.id = 'analytics-dashboard-styles';
          style.textContent = `
            .analytics-dashboard {
              background: var(--bg-container);
              border-radius: 8px;
              padding: 1rem;
              margin-top: 1rem;
              box-shadow: var(--shadow-sm);
            }
            .analytics-dashboard h3 {
              margin-top: 0;
              color: var(--text-color);
              font-size: 1.1rem;
              border-bottom: 1px solid var(--border-color);
              padding-bottom: 0.5rem;
            }
            .metric {
              display: flex;
              justify-content: space-between;
              margin-bottom: 0.5rem;
              font-size: 0.9rem;
            }
            .needs-rebalance {
              color: var(--danger-color);
              font-weight: bold;
            }
            .balanced {
              color: var(--success-color);
              font-weight: bold;
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // Calculate expected return: sharpe ratio * volatility + risk-free rate
      const expectedReturn = (metrics.volatility * metrics.sharpeRatio + FINANCIAL_CONSTANTS.RISK_FREE_RATE) * 100;
      
      dashboard.innerHTML = `
        <h3><i class="fas fa-chart-line"></i> Portfolio Analytics</h3>
        <div class="metric">
          <span>Expected Return:</span>
          <span>${expectedReturn.toFixed(2)}%</span>
        </div>
        <div class="metric">
          <span>Volatility:</span>
          <span>${(metrics.volatility * 100).toFixed(2)}%</span>
        </div>
        <div class="metric">
          <span>Sharpe Ratio:</span>
          <span>${metrics.sharpeRatio.toFixed(2)}</span>
        </div>
        <div class="metric">
          <span>Beta:</span>
          <span>${metrics.beta.toFixed(2)}</span>
        </div>
        <div class="metric">
          <span>Tax Impact:</span>
          <span>$${taxImpact.toFixed(2)}</span>
        </div>
        <div class="metric">
          <span>Rebalance Status:</span>
          <span class="${needsRebalance ? 'needs-rebalance' : 'balanced'}">
            ${needsRebalance ? 'Rebalance Needed' : 'Balanced'}
          </span>
        </div>
      `;
      
      // Add to DOM if new
      if (!dashboard.parentNode) {
        const section = document.querySelector('.section');
        if (section) {
          section.appendChild(dashboard);
        }
      }
    } catch (error) {
      console.error('Error updating analytics dashboard:', error);
    }
  }
};

// Constants and configuration
const CONFIG = {
  MIN_PORTFOLIO_VALUE: 1000,
  MAX_PORTFOLIO_VALUE: 1000000000,
  MIN_CASH_TARGET: 0,
  MAX_CASH_TARGET: 100,
  CHART_COLORS: {
    primary: '#007bff',
    success: '#28a745',
    danger: '#dc3545',
    warning: '#ffc107',
    info: '#17a2b8'
  },
  CHART_OPTIONS: {
    responsive: true,
    maintainAspectRatio: false,
    animation: {
      duration: 750,
      easing: 'easeInOutQuart'
    }
  }
};

// Chart management
const chartManager = {
  initCharts() {
    try {
      this.assetAllocationChart = this.createChart('assetAllocationChart', {
        type: 'doughnut',
        data: {
          labels: [],
          datasets: [{
            data: [],
            backgroundColor: Object.values(CONFIG.CHART_COLORS)
          }]
        },
        options: {
          ...CONFIG.CHART_OPTIONS,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const value = context.raw;
                  const percentage = ((value / totalPortfolioValue) * 100).toFixed(1);
                  return `${context.label}: ${utils.formatCurrency(value)} (${percentage}%)`;
                }
              }
            }
          }
        }
      });

      this.classAllocationChart = this.createChart('classAllocationChart', {
        type: 'doughnut',
        data: {
          labels: [],
          datasets: [{
            data: [],
            backgroundColor: Object.values(CONFIG.CHART_COLORS)
          }]
        },
        options: {
          ...CONFIG.CHART_OPTIONS,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const value = context.raw;
                  const percentage = ((value / totalPortfolioValue) * 100).toFixed(1);
                  return `${context.label}: ${utils.formatCurrency(value)} (${percentage}%)`;
                }
              }
            }
          }
        }
      });

      this.positionAllocationChart = this.createChart('positionAllocationChart', {
        type: 'doughnut',
        data: {
          labels: [],
          datasets: [{
            data: [],
            backgroundColor: Object.values(CONFIG.CHART_COLORS)
          }]
        },
        options: {
          ...CONFIG.CHART_OPTIONS,
          plugins: {
            legend: {
              position: 'right'
            },
            tooltip: {
              callbacks: {
                label: (context) => {
                  const value = context.raw;
                  const percentage = ((value / totalPortfolioValue) * 100).toFixed(1);
                  return `${context.label}: ${utils.formatCurrency(value)} (${percentage}%)`;
                }
              }
            }
          }
        }
      });

      // Add risk metrics chart
      this.riskMetricsChart = this.createChart('riskMetricsChart', {
        type: 'radar',
        data: {
          labels: ['Volatility', 'Beta', 'Sharpe Ratio', 'Correlation'],
          datasets: [{
            label: 'Portfolio Metrics',
            data: [0, 0, 0, 0],
            backgroundColor: 'rgba(0, 123, 255, 0.2)',
            borderColor: CONFIG.CHART_COLORS.primary,
            pointBackgroundColor: CONFIG.CHART_COLORS.primary,
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: CONFIG.CHART_COLORS.primary
          }]
        },
        options: {
          ...CONFIG.CHART_OPTIONS,
          scales: {
            r: {
              beginAtZero: true,
              ticks: {
                stepSize: 0.2
              }
            }
          }
        }
      });

    } catch (error) {
      console.error('Error initializing charts:', error);
      utils.showError('Failed to initialize portfolio charts');
    }
  },

  createChart(canvasId, config) {
    try {
      const ctx = document.getElementById(canvasId).getContext('2d');
      return new Chart(ctx, config);
    } catch (error) {
      console.error(`Error creating chart ${canvasId}:`, error);
      throw error;
    }
  },

  updateCharts(data) {
    try {
      if (!data) return;

      // Update Asset Allocation Chart
      const assetData = this.prepareAssetData(data);
      this.assetAllocationChart.data.labels = assetData.labels;
      this.assetAllocationChart.data.datasets[0].data = assetData.values;
      this.assetAllocationChart.update();

      // Update Class Allocation Chart
      const classData = this.prepareClassData(data);
      this.classAllocationChart.data.labels = classData.labels;
      this.classAllocationChart.data.datasets[0].data = classData.values;
      this.classAllocationChart.update();

      // Update Position Allocation Chart
      const positionData = this.preparePositionData(data);
      this.positionAllocationChart.data.labels = positionData.labels;
      this.positionAllocationChart.data.datasets[0].data = positionData.values;
      this.positionAllocationChart.update();

      // Update Risk Metrics Chart
      const metrics = portfolioAnalytics.calculateRiskMetrics();
      this.riskMetricsChart.data.datasets[0].data = [
        metrics.volatility,
        metrics.beta,
        metrics.sharpeRatio,
        metrics.correlation
      ];
      this.riskMetricsChart.update();

      // Update Analytics Dashboard
      portfolioAnalytics.updateAnalyticsDashboard();

    } catch (error) {
      console.error('Error updating charts:', error);
      utils.showError('Failed to update portfolio charts');
    }
  },

  prepareAssetData(data) {
    try {
      const assetMap = new Map();
      data.forEach(item => {
        if (item.type === 'asset') {
          assetMap.set(item.name, item.currentValue);
        }
      });
      return {
        labels: Array.from(assetMap.keys()),
        values: Array.from(assetMap.values())
      };
    } catch (error) {
      console.error('Error preparing asset data:', error);
      return { labels: [], values: [] };
    }
  },

  prepareClassData(data) {
    try {
      const classMap = new Map();
      data.forEach(item => {
        if (item.type === 'class') {
          classMap.set(item.name, item.currentValue);
        }
      });
      return {
        labels: Array.from(classMap.keys()),
        values: Array.from(classMap.values())
      };
    } catch (error) {
      console.error('Error preparing class data:', error);
      return { labels: [], values: [] };
    }
  },

  preparePositionData(data) {
    try {
      const positionMap = new Map();
      data.forEach(item => {
        if (item.type === 'position') {
          positionMap.set(item.name, item.currentValue);
        }
      });
      return {
        labels: Array.from(positionMap.keys()),
        values: Array.from(positionMap.values())
      };
    } catch (error) {
      console.error('Error preparing position data:', error);
      return { labels: [], values: [] };
    }
  }
};

// Event handlers
const eventHandlers = {
  init() {
    try {
      this.setupDarkMode();
      this.setupPortfolioValue();
      this.setupCashTarget();
      this.setupRiskProfile();
      this.setupRebalanceButton();
      this.setupResetButton();
      this.setupOptimizeButton();
      this.setupTaxAnalysisButton();
    } catch (error) {
      console.error('Error initializing event handlers:', error);
      utils.showError('Failed to initialize application');
    }
  },

  setupDarkMode() {
    const toggle = document.querySelector('.dark-mode-toggle');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    
    const setDarkMode = (isDark) => {
      document.body.classList.toggle('dark-mode', isDark);
      localStorage.setItem('darkMode', isDark);
    };

    toggle.addEventListener('click', () => {
      const isDark = document.body.classList.toggle('dark-mode');
      setDarkMode(isDark);
    });

    // Initialize dark mode from localStorage or system preference
    const savedDarkMode = localStorage.getItem('darkMode');
    if (savedDarkMode !== null) {
      setDarkMode(savedDarkMode === 'true');
    } else {
      setDarkMode(prefersDark.matches);
    }

    // Listen for system dark mode changes
    prefersDark.addEventListener('change', (e) => {
      if (localStorage.getItem('darkMode') === null) {
        setDarkMode(e.matches);
      }
    });
  },

  setupPortfolioValue() {
    const portfolioValue = document.getElementById('portfolioValue');
    const input = document.createElement('input');
    input.type = 'number';
    input.value = portfolioValue.textContent.replace(/[^0-9.]/g, '');
    input.className = 'editable-field';
    input.min = CONFIG.MIN_PORTFOLIO_VALUE;
    input.max = CONFIG.MAX_PORTFOLIO_VALUE;
    input.step = 1000;

    input.addEventListener('blur', () => {
      const value = Number(input.value);
      if (utils.validateNumber(value, CONFIG.MIN_PORTFOLIO_VALUE, CONFIG.MAX_PORTFOLIO_VALUE)) {
        portfolioValue.textContent = utils.formatCurrency(value);
        this.updatePortfolioData();
      } else {
        utils.showError('Invalid portfolio value');
        input.value = portfolioValue.textContent.replace(/[^0-9.]/g, '');
      }
    });

    portfolioValue.textContent = '';
    portfolioValue.appendChild(input);
  },

  setupCashTarget() {
    const cashTargetInput = document.getElementById('cashTargetInput');
    cashTargetInput.addEventListener('change', () => {
      const value = Number(cashTargetInput.value);
      if (utils.validateNumber(value, CONFIG.MIN_CASH_TARGET, CONFIG.MAX_CASH_TARGET)) {
        this.updatePortfolioData();
      } else {
        utils.showError('Invalid cash target percentage');
        cashTargetInput.value = 5;
      }
    });
  },

  setupRiskProfile() {
    const riskSelect = document.getElementById('riskSelect');
    riskSelect.addEventListener('change', () => {
      this.updatePortfolioData();
    });
  },

  setupRebalanceButton() {
    const rebalanceBtn = document.getElementById('rebalanceBtn');
    // Remove the conflicting event handler to prevent double-triggering
    /* 
    rebalanceBtn.addEventListener('click', () => {
      if (portfolioAnalytics.checkRebalancingNeeded()) {
        utils.showLoading(rebalanceBtn);
        setTimeout(() => {
          this.rebalancePortfolio();
          utils.hideLoading(rebalanceBtn);
        }, 500);
      } else {
        utils.showError('Portfolio is already balanced');
      }
    });
    */
  },

  setupResetButton() {
    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to reset all changes?')) {
        this.resetPortfolio();
      }
    });
  },

  setupOptimizeButton() {
    const optimizeBtn = document.createElement('button');
    optimizeBtn.className = 'btn btn-success';
    optimizeBtn.innerHTML = '<i class="fas fa-chart-line"></i> Optimize Portfolio';
    optimizeBtn.addEventListener('click', () => {
      utils.showLoading(optimizeBtn);
      setTimeout(() => {
        portfolioAnalytics.optimizePortfolio();
        utils.hideLoading(optimizeBtn);
      }, 500);
    });
    document.querySelector('.profile-actions').appendChild(optimizeBtn);
  },

  setupTaxAnalysisButton() {
    const taxBtn = document.createElement('button');
    taxBtn.className = 'btn btn-info';
    taxBtn.innerHTML = '<i class="fas fa-calculator"></i> Tax Analysis';
    taxBtn.addEventListener('click', () => {
      const taxImpact = portfolioAnalytics.calculateTaxImplications();
      alert(`Estimated Tax Impact: ${utils.formatCurrency(taxImpact)}`);
    });
    document.querySelector('.profile-actions').appendChild(taxBtn);
  },

  async updatePortfolioData() {
    try {
      utils.showLoading(document.querySelector('.container'));
      const portfolioValue = Number(document.getElementById('portfolioValue').querySelector('input').value);
      const cashTarget = Number(document.getElementById('cashTargetInput').value);
      const riskProfile = document.getElementById('riskSelect').value;

      const response = await fetch('/api/portfolio-data', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          portfolioValue,
          cashTarget,
          riskProfile
        })
      });

      if (!response.ok) {
        throw new Error('Failed to update portfolio data');
      }

      const data = await response.json();
      portfolioState.setData(data);
    } catch (error) {
      console.error('Error updating portfolio data:', error);
      utils.showError(error.message);
    } finally {
      utils.hideLoading(document.querySelector('.container'));
    }
  },

  async rebalancePortfolio() {
    try {
      utils.showLoading(document.querySelector('.container'));
      const response = await fetch('/api/rebalance', {
        method: 'POST'
      });

      if (!response.ok) {
        throw new Error('Failed to rebalance portfolio');
      }

      const data = await response.json();
      portfolioState.setData(data);
    } catch (error) {
      console.error('Error rebalancing portfolio:', error);
      utils.showError(error.message);
    } finally {
      utils.hideLoading(document.querySelector('.container'));
    }
  },

  resetPortfolio() {
    document.getElementById('portfolioValue').querySelector('input').value = '100000';
    document.getElementById('cashTargetInput').value = '5';
    document.getElementById('riskSelect').value = 'moderate';
    this.updatePortfolioData();
  }
};
</script>
</body>
</html>
