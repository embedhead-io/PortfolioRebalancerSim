<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Manager Simulator (Expanded Requirements)</title>
  <style>
    /* 
      LANDSCAPE LAYOUT
      We'll give the container a fairly large max-width 
      so that the table and charts can fit side-by-side more comfortably.
    */
    body {
      margin: 0;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      background: #f8f9fa;
      /* Force a wide layout for a "landscape" feel. */
      min-width: 1200px;
    }

    .container {
      max-width: 1200px; 
      margin: 1rem auto;
      padding: 1.5rem;
      background: #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.05);
      border-radius: 5px;
    }

    h1, h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    .section {
      margin-bottom: 1.5rem;
      border-bottom: 1px solid #ddd;
      padding-bottom: 1rem;
    }

    .btn {
      padding: 0.4rem 0.8rem;
      border: none;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      border-radius: 3px;
      margin-left: 0.5rem;
      font-size: 0.9rem;
    }
    .btn:hover {
      background: #0069d9;
    }

    /* Client Profile Layout */
    #client-profile {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
    }
    .profile-info {
      flex: 1;
      min-width: 320px; 
      margin-right: 1rem;
    }
    .profile-actions {
      margin-top: 1rem;
    }

    /* 
      Risk Tolerance => now a dropdown 
      We'll display it instead of a plain text. 
    */
    #riskSelect {
      margin-left: 0.5rem;
    }

    /*
      Portfolio Value => editable; 
      add a light border to indicate it's editable.
    */
    .editable-field {
      cursor: pointer;
      border: 1px dotted #ccc; /* Light border to show editability */
      padding: 2px 4px;
      background: #fafafa;
    }
    .editable-field input {
      width: 80px;
      border: 1px solid #007bff;
      outline: none;
      font: inherit;
      box-sizing: border-box;
      text-align: right;
    }

    /* Portfolio Header: only "Reset Trades" on the right. */
    .portfolio-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .portfolio-buttons {
      display: flex;
      gap: 0.5rem;
    }

    /* Table (11 columns) with total row at the bottom. */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 0.5rem 0;
    }
    th, td {
      text-align: left;
      padding: 0.4rem;
      border-bottom: 1px solid #eee;
      vertical-align: middle;
    }
    th {
      background: #f0f0f0;
    }
    tfoot td {
      font-weight: bold;
    }

    /* Proposed columns get a dotted border. */
    .proposed-col {
      border: 1px dotted #007bff;
      background: #fafafa;
      cursor: pointer;
    }
    .proposed-col input {
      border: 1px solid #007bff;
      padding: 2px 4px;
      text-align: right;
      width: 100%;
    }

    /* 
      Swap Red/Green: 
        negative => red, 
        positive => green, 
        zero => black
      Nonzero => bold
    */
    .delta-positive {
      color: green;
      font-weight: bold;
    }
    .delta-negative {
      color: red;
      font-weight: bold;
    }

    .charts-container {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }
    .chart-box {
      flex: 1;
      min-width: 300px;
      max-width: 480px; 
      max-height: 400px;
      position: relative;
      margin: auto;
      background: #f9f9f9;
      border-radius: 4px;
      padding: 1rem;
      text-align: center;
    }
    .chart-title {
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    .chart-box canvas {
      width: 100% !important;
      height: 100% !important;
    }

    .footer {
      text-align: center;
      margin-top: 2rem;
      font-size: 0.85rem;
      color: #666;
    }

    .success {
      color: green;
      font-weight: bold;
    }
    .error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>Portfolio Manager Simulator</h1>

  <!-- SECTION: CLIENT PROFILE -->
  <div class="section">
    <h2>Client Profile</h2>
    <div id="client-profile">
      <div class="profile-info">
        <p>
          <strong>Name:</strong>
          <span id="clientName">--</span>
        </p>
        <p>
          <strong>Risk Tolerance:</strong>
          <!-- Use a <select> for the 3 models: Conservative, Moderate, Aggressive. -->
          <select id="riskSelect">
            <option value="conservative">Conservative</option>
            <option value="moderate" selected>Moderate</option>
            <option value="aggressive">Aggressive</option>
          </select>
        </p>
        <p>
          <strong>Portfolio Value:</strong>
          $<span id="clientValue" class="editable-field">0</span>
        </p>
        <p>
          <strong>Target Allocation:</strong>
          <span id="targetStocks">--</span>% Stocks, 
          <span id="targetBonds">--</span>% Bonds, 
          <span id="targetCash">--</span>% Cash
        </p>

        <div class="profile-actions">
          <button class="btn" id="newClientBtn">Generate New Client</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SECTION: CURRENT (or Projected) PORTFOLIO -->
  <div class="section">
    <div class="portfolio-header">
      <h2>Current (or Projected) Portfolio</h2>
      <div class="portfolio-buttons">
        <button class="btn" id="resetTradesBtn">Reset Trades</button>
      </div>
    </div>

    <!-- 11 columns in requested order:
        Asset, Current($), Target($), Proposed($), Final($), Delta($),
        Current(%), Target(%), Proposed(%), Final(%), Delta(%)
    -->
    <table id="portfolioTable">
      <thead>
        <tr>
          <th>Asset</th>
          <th>Current ($)</th>
          <th>Target ($)</th>
          <th>Proposed +/- ($)</th>
          <th>Final ($)</th>
          <th>Delta ($)</th>
          <th>Current (%)</th>
          <th>Target (%)</th>
          <th>Proposed +/- (%)</th>
          <th>Final (%)</th>
          <th>Delta (%)</th>
        </tr>
      </thead>
      <tbody id="portfolioRows"></tbody>
      <tfoot>
        <tr id="totalRow"></tr>
      </tfoot>
    </table>

    <div class="charts-container">
      <!-- LEFT: Target Chart -->
      <div class="chart-box">
        <div class="chart-title">Target Allocation</div>
        <canvas id="targetChart"></canvas>
      </div>
      <!-- RIGHT: Final Chart -->
      <div class="chart-box">
        <div class="chart-title">Final Allocation</div>
        <canvas id="finalChart"></canvas>
      </div>
    </div>

    <p id="tradeMessage"></p>
  </div>
</div>

<div class="footer">
  &copy; Requirements: Reset Bug Fix, Risk Dropdown, Negative=Red, Positive=Green, etc.
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/**
 * KEY CHANGES:
 * 1) We store an "originalAssets" baseline. On "Reset Trades," we restore from that baseline 
 *    so the entire scenario returns to the initial state.
 * 2) Negative => red, Positive => green, zero => black, + bold if nonzero.
 * 3) Risk Tolerance => <select> updates target distribution immediately. 
 * 4) Delta(%) has "%" appended. 
 * 5) Resizing layout for a landscape feel (max-width: 1200px).
 * 6) Proposed columns have dotted border, portfolioValue also has a dotted border.
 */

let totalPortfolioValue = 0;
// We'll store "assets" for the live state, "originalAssets" as a baseline for reset.
let assets = [];
let originalAssets = []; 

// We'll track the user's "targetStockPct", etc. 
// Because changing risk model changes only the target distribution, not current, proposed, final.
let userStockPct= 0.5, userBondPct= 0.4, userCashPct= 0.1;

let finalChart, targetChart;

function generateRandomClient() {
  const names = ['John Smith','Jane Doe','Alex Johnson','Maria Garcia','Lee Wong'];
  const randName= names[Math.floor(Math.random()* names.length)];

  // We'll default the random client to "Moderate" distribution 
  // but the user can change to the dropdown afterwards.
  // Later we can incorporate random risk as well if desired.
  return {
    name: randName,
    portfolioValue: 100000
  };
}

/** Called on "Generate New Client" or startup. */
function newRandomClient() {
  const c= generateRandomClient();
  totalPortfolioValue= c.portfolioValue;

  document.getElementById('clientName').textContent= c.name;
  document.getElementById('clientValue').textContent= formatMoney(c.portfolioValue);

  // The user might have changed the <select> risk before, so let's read it:
  readRiskDropdown();
  // Now we know userStockPct, userBondPct, userCashPct.

  // Build a random "current" distribution that may deviate from the target distribution
  const deviate= ()=> (Math.random()*0.2 - 0.1);
  let stShare= userStockPct + deviate();
  let boShare= userBondPct  + deviate();
  let caShare= userCashPct  + deviate();
  let sum= Math.max(stShare+boShare+caShare, 0.0001);

  let stPct= stShare/sum;
  let boPct= boShare/sum;
  let caPct= caShare/sum;

  // current($)
  let curSt= stPct* totalPortfolioValue;
  let curBo= boPct* totalPortfolioValue;
  let curCa= caPct* totalPortfolioValue;

  assets= [
    {
      name: 'Stocks',
      currentDollar: curSt,
      currentPct: (curSt/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curSt,
      finalPct: (curSt/ totalPortfolioValue)*100,
      // target is determined by userStockPct 
    },
    {
      name: 'Bonds',
      currentDollar: curBo,
      currentPct: (curBo/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curBo,
      finalPct: (curBo/ totalPortfolioValue)*100
    },
    {
      name: 'Cash',
      currentDollar: curCa,
      currentPct: (curCa/ totalPortfolioValue)*100,
      proposedDollar:0,
      proposedPct:0,
      finalDollar: curCa,
      finalPct: (curCa/ totalPortfolioValue)*100
    }
  ];
  // fill target distribution
  updateTargetDistribution();

  // Clone to originalAssets so we can revert 
  originalAssets= JSON.parse(JSON.stringify(assets));

  document.getElementById('tradeMessage').textContent= '';
  renderTableAndCharts();
}

/** 
 * We read the #riskSelect dropdown and store userStockPct, userBondPct, userCashPct 
 * Then we update the displayed "Target Allocation" text. 
 * Then we recalc the target amounts for each row.
 */
function readRiskDropdown() {
  const sel= document.getElementById('riskSelect');
  const val= sel.value; // 'conservative','moderate','aggressive'

  if(val==='conservative'){
    userStockPct= 0.3; 
    userBondPct= 0.5; 
    userCashPct= 0.2;
  } else if(val==='aggressive'){
    userStockPct= 0.7; 
    userBondPct= 0.2; 
    userCashPct= 0.1;
  } else {
    // default moderate
    userStockPct= 0.5; 
    userBondPct= 0.4; 
    userCashPct= 0.1;
  }
  document.getElementById('targetStocks').textContent= (userStockPct*100).toFixed(0);
  document.getElementById('targetBonds').textContent = (userBondPct*100).toFixed(0);
  document.getElementById('targetCash').textContent  = (userCashPct*100).toFixed(0);
}

/** 
 * Called whenever the risk model changes or we create a new scenario. 
 * We recalc each row's targetDollar & targetPct based on userStockPct etc. 
 * We do NOT alter current/proposed/final. 
 */
function updateTargetDistribution() {
  // userStockPct, userBondPct, userCashPct define the fraction for each asset
  // We'll match them up with assets in order: 
  //    [0]= Stocks => userStockPct
  //    [1]= Bonds  => userBondPct
  //    [2]= Cash   => userCashPct
  // Then we recalc targetDollar= totalPortfolioValue * fraction
  for(let i=0; i< assets.length; i++){
    let frac= 0;
    if(i===0) frac= userStockPct;
    else if(i===1) frac= userBondPct;
    else frac= userCashPct;

    assets[i].targetDollar= frac* totalPortfolioValue;
    assets[i].targetPct= frac*100;
  }
}

/** Rebuild the table with the updated data, recalc deltas, then update charts. */
function renderTableAndCharts(){
  updateTargetDistribution(); // ensure target columns reflect userStockPct changes

  const tbody= document.getElementById('portfolioRows');
  tbody.innerHTML='';

  let sumCurrentD=0, sumTargetD=0, sumProposedD=0, sumFinalD=0;
  let sumCurrentPct=0, sumTargetPct=0, sumProposedPct=0, sumFinalPct=0;

  assets.forEach( (row,idx)=>{
    // Delta($)= finalDollar - targetDollar
    const deltaDollar= row.finalDollar - row.targetDollar;
    // Delta(%)= finalPct - targetPct
    const deltaPct= row.finalPct - row.targetPct;

    sumCurrentD   += row.currentDollar;
    sumTargetD    += row.targetDollar;
    sumProposedD  += row.proposedDollar;
    sumFinalD     += row.finalDollar;
    sumCurrentPct += row.currentPct;
    sumTargetPct  += row.targetPct;
    sumProposedPct+= row.proposedPct;
    sumFinalPct   += row.finalPct;

    const tr= document.createElement('tr');

    // (1) Asset
    const tdAsset= document.createElement('td');
    tdAsset.textContent= row.name;
    tr.appendChild(tdAsset);

    // (2) Current($)
    const tdCurD= document.createElement('td');
    tdCurD.textContent= formatMoney(row.currentDollar);
    tr.appendChild(tdCurD);

    // (3) Target($)
    const tdTarD= document.createElement('td');
    tdTarD.textContent= formatMoney(row.targetDollar);
    tr.appendChild(tdTarD);

    // (4) Proposed($)
    const tdPropD= document.createElement('td');
    tdPropD.className= 'proposed-col';
    tdPropD.textContent= formatMoney(row.proposedDollar);
    tdPropD.onclick= ()=> editProposedCell(tdPropD, idx, 'dollar');
    tr.appendChild(tdPropD);

    // (5) Final($)
    const tdFinD= document.createElement('td');
    tdFinD.textContent= formatMoney(row.finalDollar);
    tr.appendChild(tdFinD);

    // (6) Delta($)
    const tdDeltaD= document.createElement('td');
    tdDeltaD.textContent= formatMoney(deltaDollar);
    colorDeltaCell(tdDeltaD, deltaDollar);
    tr.appendChild(tdDeltaD);

    // (7) Current(%)
    const tdCurP= document.createElement('td');
    tdCurP.textContent= row.currentPct.toFixed(2)+'%';
    tr.appendChild(tdCurP);

    // (8) Target(%)
    const tdTarP= document.createElement('td');
    tdTarP.textContent= row.targetPct.toFixed(2)+'%';
    tr.appendChild(tdTarP);

    // (9) Proposed(%)
    const tdPropP= document.createElement('td');
    tdPropP.className= 'proposed-col';
    tdPropP.textContent= row.proposedPct.toFixed(2)+'%';
    tdPropP.onclick= ()=> editProposedCell(tdPropP, idx, 'percent');
    tr.appendChild(tdPropP);

    // (10) Final(%)
    const tdFinP= document.createElement('td');
    tdFinP.textContent= row.finalPct.toFixed(2)+'%';
    tr.appendChild(tdFinP);

    // (11) Delta(%)
    const tdDeltaP= document.createElement('td');
    let dPctStr= formatDeltaPct(deltaPct);
    tdDeltaP.textContent= dPctStr;
    colorDeltaCell(tdDeltaP, parseFloat(dPctStr));
    tr.appendChild(tdDeltaP);

    tbody.appendChild(tr);
  });

  // Totals row
  const tfoot= document.getElementById('totalRow');
  tfoot.innerHTML= '';

  const sumDeltaDollar= sumFinalD - sumTargetD;
  const sumDeltaPct   = sumFinalPct - sumTargetPct;

  // 11 columns
  const col1= document.createElement('td');
  col1.textContent= 'TOTAL';
  tfoot.appendChild(col1);

  const col2= document.createElement('td');
  col2.textContent= formatMoney(sumCurrentD);
  tfoot.appendChild(col2);

  const col3= document.createElement('td');
  col3.textContent= formatMoney(sumTargetD);
  tfoot.appendChild(col3);

  const col4= document.createElement('td');
  col4.textContent= formatMoney(sumProposedD);
  tfoot.appendChild(col4);

  const col5= document.createElement('td');
  col5.textContent= formatMoney(sumFinalD);
  tfoot.appendChild(col5);

  const col6= document.createElement('td');
  col6.textContent= formatMoney(sumDeltaDollar);
  colorDeltaCell(col6, sumDeltaDollar);
  tfoot.appendChild(col6);

  const col7= document.createElement('td');
  col7.textContent= sumCurrentPct.toFixed(2)+'%';
  tfoot.appendChild(col7);

  const col8= document.createElement('td');
  col8.textContent= sumTargetPct.toFixed(2)+'%';
  tfoot.appendChild(col8);

  const col9= document.createElement('td');
  col9.textContent= sumProposedPct.toFixed(2)+'%';
  tfoot.appendChild(col9);

  const col10= document.createElement('td');
  col10.textContent= sumFinalPct.toFixed(2)+'%';
  tfoot.appendChild(col10);

  const col11= document.createElement('td');
  let sumDpctStr= formatDeltaPct(sumDeltaPct);
  col11.textContent= sumDpctStr;
  colorDeltaCell(col11, parseFloat(sumDpctStr));
  tfoot.appendChild(col11);

  // Update charts
  updateCharts();
}

/** Single-click editing for Proposed columns. */
function editProposedCell(cell, assetIndex, mode){
  let oldVal= cell.textContent.replace(/[^\d.-]/g,'');
  cell.onclick= null;
  cell.innerHTML= '';

  const input= document.createElement('input');
  input.type= 'text';
  input.value= oldVal||'0';
  setTimeout(()=> input.select(),0);

  input.onblur= ()=> finishProposedEdit(cell, input.value, assetIndex, mode);
  input.onkeydown= (ev)=>{
    if(ev.key==='Enter'){
      ev.preventDefault();
      input.blur();
    }
  };
  cell.appendChild(input);
  input.focus();
}

/** 
 * Proposed(%) => Proposed($)= (Proposed(%)/100)* totalPortfolioValue 
 * Final($)= Current($)+ Proposed($)
 * Then recalc finalPct= final$/ totalPortfolioValue *100
 */
function finishProposedEdit(cell, rawVal, assetIndex, mode){
  let val= parseFloat(rawVal)||0;
  const row= assets[assetIndex];

  if(mode==='percent'){
    row.proposedPct= val;
    row.proposedDollar= (val/100)* totalPortfolioValue;
    row.finalDollar= row.currentDollar + row.proposedDollar;
    row.finalPct= (row.finalDollar/ totalPortfolioValue)*100;
  } else {
    // dollar
    row.proposedDollar= val;
    row.proposedPct= (val/ totalPortfolioValue)*100;
    row.finalDollar= row.currentDollar + val;
    row.finalPct= (row.finalDollar/ totalPortfolioValue)*100;
  }

  renderTableAndCharts();
  // restore single-click
  if(mode==='percent'){
    cell.textContent= row.proposedPct.toFixed(2)+'%';
    cell.onclick= ()=> editProposedCell(cell, assetIndex, 'percent');
  } else {
    cell.textContent= formatMoney(row.proposedDollar);
    cell.onclick= ()=> editProposedCell(cell, assetIndex, 'dollar');
  }
}

/**
 * BUG Fix: Reset trades => restore entire scenario to "initial" state 
 * (the state after random generation).
 * That means we discard *all* user changes for current, proposed, final, etc.
 */
function doResetTrades(){
  // Copy from originalAssets to the live array
  assets= JSON.parse(JSON.stringify(originalAssets));
  // Also revert totalPortfolioValue if needed?
  // The user might have changed the portfolioValue. 
  // The requirement says "reset ... to their initial allocations."
  // We'll also revert the entire portfolioValue?
  // The request says "reset other values to their initial allocations." 
  // So let's revert to the initial portfolioValue as well.
  if(originalPortfolioValue !== undefined){
    totalPortfolioValue= originalPortfolioValue;
    document.getElementById('clientValue').textContent= formatMoney(totalPortfolioValue);
  }

  document.getElementById('tradeMessage').textContent= 'Trades and allocations have been reset to the initial scenario.';
  renderTableAndCharts();
}

/** We'll store the initial portfolioValue in originalPortfolioValue upon new random client. */
let originalPortfolioValue= 0;

/** 
 * We also make the portfolio value itself editable. 
 * This modifies the entire distribution proportionally if changed.
 */
(function enablePortfolioValueEdit(){
  const valSpan= document.getElementById('clientValue');
  valSpan.addEventListener('click', function onClick(){
    const oldValStr= valSpan.textContent.replace(/[^\d.-]/g,'');
    const oldVal= parseFloat(oldValStr)||0;

    // remove the click
    valSpan.onclick= null;
    valSpan.innerHTML= '';

    const inp= document.createElement('input');
    inp.type= 'text';
    inp.value= oldValStr||'0';
    setTimeout(()=>inp.select(),0);

    inp.onblur= ()=> finishValEdit(inp.value, oldVal);
    inp.onkeydown= (ev)=>{
      if(ev.key==='Enter'){
        ev.preventDefault();
        inp.blur();
      }
    };
    valSpan.appendChild(inp);
    inp.focus();

    function finishValEdit(newStr, oldVal){
      let newVal= parseFloat(newStr)||0;
      if(newVal<=0) newVal= oldVal; // revert if invalid

      if(Math.abs(newVal - oldVal)>0.00001 && oldVal>0){
        let scale= newVal / oldVal;
        totalPortfolioValue= newVal;
        // scale all assets
        assets.forEach(a=>{
          a.currentDollar *= scale;
          a.targetDollar  *= scale;
          a.proposedDollar*= scale;
          a.finalDollar   *= scale;

          a.currentPct= (a.currentDollar/ newVal)*100;
          a.targetPct=  (a.targetDollar/  newVal)*100;
          a.proposedPct=(a.proposedDollar/ newVal)*100;
          a.finalPct=   (a.finalDollar/   newVal)*100;
        });
        renderTableAndCharts();
      }
      valSpan.textContent= formatMoney(newVal);
      valSpan.onclick= onClick;
    }
  });
})();

/** Helper: color Delta columns => negative => red, positive => green, 0 => black, bold if nonzero. */
function colorDeltaCell(td, val){
  td.classList.remove('delta-positive','delta-negative');
  // Negative => red, positive => green, zero => black
  if(val<0) td.classList.add('delta-negative');
  else if(val>0) td.classList.add('delta-positive');
  else {
    // zero => remove both classes => black normal weight
  }
}

/** Format Delta(%) to 2 decimals, no negative zero, plus a "%" sign. */
function formatDeltaPct(num){
  let r= parseFloat(num.toFixed(2));
  if(Math.abs(r)<0.005) r=0;
  return r.toFixed(2);
}

/** Chart updates => left= target, right= final. */
function updateCharts(){
  // Summaries for target/final
  const tarVals= assets.map(a=> a.targetDollar);
  const finVals= assets.map(a=> a.finalDollar);
  const labels= assets.map(a=> a.name);

  targetChart.data.labels= labels;
  targetChart.data.datasets[0].data= tarVals;
  targetChart.update();

  finalChart.data.labels= labels;
  finalChart.data.datasets[0].data= finVals;
  finalChart.update();
}

/** Format dollars w/ thousands separators. */
function formatMoney(x){
  return new Intl.NumberFormat('en-US',{
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(x);
}

/** Initialize the pie charts. */
function initCharts(){
  targetChart= new Chart(document.getElementById('targetChart'),{
    type:'pie',
    data:{
      labels: [],
      datasets:[{
        label:'Target Allocation',
        data: [],
        backgroundColor: ['#2196f3','#8bc34a','#ffc107']
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:true,
      plugins:{legend:{position:'bottom'}}
    }
  });

  finalChart= new Chart(document.getElementById('finalChart'),{
    type:'pie',
    data:{
      labels: [],
      datasets:[{
        label:'Final Allocation',
        data: [],
        backgroundColor: ['#2196f3','#8bc34a','#ffc107']
      }]
    },
    options:{
      responsive:true,
      maintainAspectRatio:true,
      plugins:{legend:{position:'bottom'}}
    }
  });
}

/** On load => read risk select => new random client => store baseline => done. */
window.addEventListener('DOMContentLoaded', ()=>{
  initCharts();

  // read the risk select whenever changed
  document.getElementById('riskSelect').addEventListener('change', ()=>{
    readRiskDropdown(); 
    // We do not revert current. We only update target distribution. 
    // Then re-render:
    renderTableAndCharts();
  });

  document.getElementById('newClientBtn').addEventListener('click', ()=>{
    // We'll also store the baseline portfolioValue
    newRandomClient();
    originalPortfolioValue= totalPortfolioValue;
  });

  document.getElementById('resetTradesBtn').addEventListener('click', doResetTrades);

  // Start with the default "moderate" risk, read it, generate a scenario
  readRiskDropdown(); 
  newRandomClient();
  originalPortfolioValue= totalPortfolioValue;
});
</script>
</body>
</html>
